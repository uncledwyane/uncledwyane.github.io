{"pages":[],"posts":[{"title":"使用SVP给视频插帧，看电影如丝半顺滑","text":"使用SVP4Pro(破解版)，搭配Potplayer让电影帧率达到60帧或者以上帧率，看电影或者视频很顺滑。 前提svp4pro下载地址：点我 提取码：e93d 安装了potplayer 下载提供的链接里的所有内容 解压下载的压缩包 下载后的文件如下，解压里面的svp压缩包： 开始安装 将解压出来的SVP文件夹移动到C盘根目录 打开svp4-cracked这个软件，点击左下角setting，按照下图添加本地svp目录，不用去网上下载： 在上面第5步输入框中输入file:///C:/SVP/common，再同样点击add添加一个file:///C:/SVP/free，最终如下图所示： 点击ok然后next选择自己安装的版本： 然后一路next安装，直到安装完成，最后先别打开软件！！！ 使用下载的包里面的SVPManager复制到C:/Commonfiles(x86)/SVP4，替换里面的同名文件 打开SVPManager，根据自己电脑性能来设置： 最后点击左上角图标，然后点击图标设置一下，防止svp对视频画面进行裁切： 打开potplayer，右键选项设置： 关闭内置视频处理滤镜 点击系统滤镜，添加滤镜 选择ffdshow Video Decoder，点击确定： 最后勾选滤镜，然后强制使用，确定 打开potplayer，随便播放一个视频，按tab键查看播放信息，已经补帧到60了：","link":"/2020/05/26/pc-svp4pro/"},{"title":"Windows10&#x2F;Office系列软件激活教程","text":"这个教程仅在Win10和Office16以后的版本做过测试并通过，其它Windows系统和其它Office软件版本未作测试，可以自行激活。 点击下方“阅读更多”进入教程 激活前提 退出Windows自带安全软件或者360等安全软件，此激活程序请放心使用 下载KMS程序压缩包，点击下方链接下载KMS 下载完成后解压，得到一个名为KMS文件夹 进入文件夹，点击KMSpico_setup.exe进行安装 下载链接：https://pan.baidu.com/s/1hsnChXWHXtkC2GEZzqgH4w 提取码: yavm 开始 执行上一步之后，不会显示软件界面，后台自动激活，听到Program Complete表示激活完成 激活完成","link":"/2020/02/22/tips-win-active/"},{"title":"Node笔记","text":"Node的学习笔记 为什么要学习Node.js 企业需求 具有服务端开发经验更改 front-end back-end 全栈开发工程师 基本的网站开发能力 服务端 前端 运维部署 多人社区 Node.js是什么 Node.js是JavaScript 运行时 通俗易懂的讲，Node.js是JavaScript的运行平台 Node.js既不是语言，也不是框架，它是一个平台 浏览器中的JavaScript EcmaScript 基本语法 if var function Object Array Bom Dom Node.js中的JavaScript 没有Bom，Dom EcmaScript 在Node中这个JavaScript执行环境为JavaScript提供了一些服务器级别的API 例如文件的读写 网络服务的构建 网络通信 http服务器 构建与Chrome的V8引擎之上 代码只是具有特定格式的字符串 引擎可以认识它，帮你解析和执行 Google Chrome的V8引擎是目前公认的解析执行JavaScript代码最快的 Node.js的作者把Google Chrome中的V8引擎移植出来，开发了一个独立的JavaScript运行时环境 Node.js uses an envent-driven,non-blocking I/O mode that makes it lightweight and efficent. envent-driven 事件驱动 non-blocking I/O mode 非阻塞I/O模型（异步） ightweight and efficent. 轻量和高效 Node.js package ecosystem,npm,is the larget scosystem of open sourcr libraries in the world npm 是世界上最大的开源生态系统 绝大多数JavaScript相关的包都存放在npm上，这样做的目的是为了让开发人员更方便的去下载使用 npm install jquery Node能做什么 web服务器后台 命令行工具 npm(node) git(c语言) hexo（node） … 对于前端工程师来讲，接触最多的是它的命令行工具 自己写的很少，主要是用别人第三方的 webpack gulp npm 起步安装Node环境 查看Node环境的版本号 下载：https://nodejs.org/en/ 安装： 傻瓜式安装，一路next 安装过再次安装会升级 确认Node环境是否安装成功 查看node的版本号：node --version 或者node -v 配置环境变量 解析执行JavaScript 创建编写JavaScript脚本文件 打开终端，定位脚本文件的所属目录 输入node 文件名执行对应的文件 注意：文件名不要用node.js来命名，也就是说除了node这个名字随便起，最好不要使用中文。 文件的读写文件读取: 12345678910111213141516171819//浏览器中的JavaScript是没有文件操作能力的//但是Node中的JavaScript具有文件操作能力//fs是file-system的简写，就是文件系统的意思//在Node中如果想要进行文件的操作就必须引用fs这个核心模块//在fs这个和兴模块中，就提供了人所有文件操作相关的API//例如 fs.readFile就是用来读取文件的// 1.使用fs核心模块var fs = require('fs');// 2.读取文件fs.readFile('./data/a.txt',function(err,data){ if(err){ console.log('文件读取失败'); } else{ console.log(data.toString()); }}) 文件写入： 123456789101112// 1.使用fs核心模块var fs = require('fs');// 2.将数据写入文件fs.writeFile('./data/a.txt','我是文件写入的信息',function(err,data){ if(err){ console.log('文件写入失败'); } else{ console.log(data.toString()); }}) http服务器： 12345678910111213141516171819202122// 1.加载http核心模块var http = require('http');// 2.使用http.createServer()创建一个web服务器var server = http.createServer();// 3.服务器要做的事儿// 提供服务：对数据服务// 发请求// 接收请求// 处理请求// 反馈（发送响应）// 当客户端请求过来，就会自动触发服务器的request请求事件，然后执行第二个参数：回调处理函数server.on('request',function(){ console.log('收到客户的请求了')})// 4.绑定端口号，启动服务server.listen(3000,function(){ console.log('runing...')}) Node中的模块系统使用Node编写应用程序主要就是在使用： EcmaScript语言 和浏览器一样，在Node中没有Bom和Dom 核心模块 文件操作的fs http服务操作的http url路径操作模块 path路径处理模块 os操作系统信息 第三方模块 art-template 必须通过npm来下载才可以使用 自己写的模块 自己创建的文件 什么是模块化 文件作用域(模块是独立的，在不同的文件使用必须要重新引用)【在node中没有全局作用域，它是文件模块作用域】 通信规则 加载require 导出exports CommonJS模块规范在Node中的JavaScript还有一个重要的概念，模块系统。 模块作用域 使用require方法来加载模块 使用exports接口对象来导出模板中的成员 加载require语法： 1var 自定义变量名 = require('模块') 作用： 执行被加载模块中的代码 得到被加载模块中的exports导出接口对象 导出exports Node中是模块作用域，默认文件中所有的成员只在当前模块有效 对于希望可以被其他模块访问到的成员，我们需要把这些公开的成员都挂载到exports接口对象中就可以了 导出多个成员（必须在对象中）： 12345678exports.a = 123;exports.b = function(){ console.log('bbb')};exports.c = { foo:&quot;bar&quot;};exports.d = 'hello'; 导出单个成员（拿到的就是函数，字符串）： 1module.exports = 'hello'; 以下情况会覆盖： 12345module.exports = 'hello';//后者会覆盖前者module.exports = function add(x,y) { return x+y;} 也可以通过以下方法来导出多个成员： 123456module.exports = { foo = 'hello', add:function(){ return x+y; }}; 模块原理exports和module.exports的一个引用： 123456console.log(exports === module.exports); //trueexports.foo = 'bar';//等价于module.exports.foo = 'bar'; 当给exports重新赋值后，exports！= module.exports. 最终return的是module.exports,无论exports中的成员是什么都没用。 123真正去使用的时候： 导出单个成员：exports.xxx = xxx; 导出多个成员：module.exports 或者 modeule.exports = {}; 总结12345678910111213141516171819202122232425262728293031323334// 引用服务var http = require('http');var fs = require('fs');// 引用模板var template = require('art-template');// 创建服务var server = http.createServer();// 公共路径var wwwDir = 'D:/app/www';server.on('request', function (req, res) { var url = req.url; // 读取文件 fs.readFile('./template-apche.html', function (err, data) { if (err) { return res.end('404 Not Found'); } fs.readdir(wwwDir, function (err, files) { if (err) { return res.end('Can not find www Dir.') } // 使用模板引擎解析替换data中的模板字符串 // 去xmpTempleteList.html中编写模板语法 var htmlStr = template.render(data.toString(), { title: 'D:/app/www/ 的索引', files:files }); // 发送响应数据 res.end(htmlStr); }) })});server.listen(3000, function () { console.log('running....');}) 1234567891011121314151617181.jQuery中的each 和 原生JavaScript方法forEach的区别： 提供源头： 原生js是es5提供的（不兼容IE8）, jQuery的each是jQuery第三方库提供的（如果要使用需要用2以下的版本也就是1.版本）,它的each方法主要用来遍历jQuery实例对象（伪数组）,同时也可以做低版本forEach的替代品,jQuery的实例对象不能使用forEach方法，如果想要使用必须转为数组（[].slice.call(jQuery实例对象)）才能使用2.模块中导出多个成员和导出单个成员3.301和302的区别： 301永久重定向,浏览器会记住 302临时重定向4.exports和module.exports的区别: 每个模块中都有一个module对象 module对象中有一个exports对象 我们可以把需要导出的成员都挂载到module.exports接口对象中 也就是`module.exports.xxx = xxx`的方式 但是每次写太多了就很麻烦，所以Node为了简化代码，就在每一个模块中都提供了一个成员叫`exports` `exports === module.exports`结果为true,所以完全可以`exports.xxx = xxx` 当一个模块需要导出单个成员的时候必须使用`module.exports = xxx`的方式，=,使用`exports = xxx`不管用,因为每个模块最终return的是module.exports,而exports只是module.exports的一个引用,所以`exports`即使重新赋值,也不会影响`module.exports`。 有一种赋值方式比较特殊：`exports = module.exports`这个用来新建立引用关系的。 require的加载规则 核心模块 模块名 第三方模块 模块名 用户自己写的 路径 require的加载规则： 优先从缓存加载 判断模块标识符 核心模块 自己写的模块（路径形式的模块） 第三方模块（node_modules） 第三方模块的标识就是第三方模块的名称（不可能有第三方模块和核心模块的名字一致） npm 开发人员可以把写好的框架库发布到npm上 使用者通过npm命令来下载 使用方式：var 名称 = require('npm install【下载包】 的包名') node_modules/express/package.json main 如果package.json或者main不成立，则查找被选择项：index.js 如果以上条件都不满足，则继续进入上一级目录中的node_modules按照上面的规则依次查找，直到当前文件所属此盘根目录都找不到最后报错 12345678910111213141516171819202122232425262728293031323334// 如果非路径形式的标识// 路径形式的标识： // ./ 当前目录 不可省略 // ../ 上一级目录 不可省略 // /xxx也就是D:/xxx // 带有绝对路径几乎不用（D:/a/foo.js）// 首位表示的是当前文件模块所属磁盘根目录// require('./a'); // 核心模块// 核心模块本质也是文件，核心模块文件已经被编译到了二进制文件中了，我们只需要按照名字来加载就可以了require('fs'); // 第三方模块// 凡是第三方模块都必须通过npm下载（npm i node_modules），使用的时候就可以通过require('包名')来加载才可以使用// 第三方包的名字不可能和核心模块的名字是一样的// 既不是核心模块，也不是路径形式的模块// 先找到当前文所述目录的node_modules// 然后找node_modules/art-template目录// node_modules/art-template/package.json// node_modules/art-template/package.json中的main属性// main属性记录了art-template的入口模块// 然后加载使用这个第三方包// 实际上最终加载的还是文件// 如果package.json不存在或者mian指定的入口模块不存在// 则node会自动找该目录下的index.js// 也就是说index.js是一个备选项，如果main没有指定，则加载index.js文件// // 如果条件都不满足则会进入上一级目录进行查找// 注意：一个项目只有一个node_modules，放在项目根目录中，子目录可以直接调用根目录的文件var template = require('art-template'); 模块标识符中的/和文件操作路径中的/文件操作路径： 1234567891011121314// 咱们所使用的所有文件操作的API都是异步的// 就像ajax请求一样// 读取文件// 文件操作中 ./ 相当于当前模块所处磁盘根目录// ./index.txt 相对于当前目录// /index.txt 相对于当前目录// /index.txt 绝对路径,当前文件模块所处根目录// d:express/index.txt 绝对路径fs.readFile('./index.txt',function(err,data){ if(err){ return console.log('读取失败'); } console.log(data.toString());}) 模块操作路径： 123// 在模块加载中，相对路径中的./不能省略// 这里省略了.也是磁盘根目录require('./index')('hello') npm node package manage(node包管理器) 通过npm命令安装jQuery包（npm install –save jquery），在安装时加上–save会主动生成说明书文件信息（将安装文件的信息添加到package.json里面） npm网站 ​ npmjs.com 网站 是用来搜索npm包的 npm命令行工具npm是一个命令行工具，只要安装了node就已经安装了npm。 npm也有版本概念，可以通过npm --version来查看npm的版本 升级npm(自己升级自己)： 1npm install --global npm 常用命令 npm init(生成package.json说明书文件) npm init -y(可以跳过向导，快速生成) npm install 一次性把dependencies选项中的依赖项全部安装 简写（npm i） npm install 包名 只下载 简写（npm i 包名） npm install –save 包名 下载并且保存依赖项（package.json文件中的dependencies选项） 简写（npm i 包名） npm uninstall 包名 只删除，如果有依赖项会依然保存 简写（npm un 包名） npm uninstall –save 包名 删除的同时也会把依赖信息全部删除 简写（npm un 包名） npm help 查看使用帮助 npm 命令 –help 查看具体命令的使用帮助（npm uninstall –help） 解决npm被墙问题npm存储包文件的服务器在国外，有时候会被墙，速度很慢，所以需要解决这个问题。 https://developer.aliyun.com/mirror/NPM?from=tnpm淘宝的开发团队把npm在国内做了一个镜像（也就是一个备份）。 安装淘宝的cnpm： 1npm install -g cnpm --registry=https://registry.npm.taobao.org; 1234#在任意目录执行都可以#--global表示安装到全局，而非当前目录#--global不能省略，否则不管用npm install --global cnpm 安装包的时候把以前的npm替换成cnpm。 12345#走国外的npm服务器下载jQuery包，速度比较慢npm install jQuery;#使用cnpm就会通过淘宝的服务器来下载jQuerycnpm install jQuery; 如果不想安装cnpm又想使用淘宝的服务器来下载： 1npm install jquery --registry=https://npm.taobao.org; 但是每次手动加参数就很麻烦，所以我们可以把这个选项加入到配置文件中： 1234npm config set registry https://npm.taobao.org;#查看npm配置信息npm config list; 只要经过上面的配置命令，则以后所有的npm install都会通过淘宝的服务器来下载 package.json每一个项目都要有一个package.json文件（包描述文件，就像产品的说明书一样） 这个文件可以通过npm init自动初始化出来 1234567891011121314151617181920212223242526272829303132333435363738D:\\code\\node中的模块系统&gt;npm initThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults.See `npm help json` for definitive documentation on these fieldsand exactly what they do.Use `npm install &lt;pkg&gt;` afterwards to install a package andsave it as a dependency in the package.json file.Press ^C at any time to quit.package name: (node中的模块系统)Sorry, name can only contain URL-friendly characters.package name: (node中的模块系统) clsversion: (1.0.0)description: 这是一个测试项目entry point: (main.js)test command:git repository:keywords:author: xiaochenlicense: (ISC)About to write to D:\\code\\node中的模块系统\\package.json:{ &quot;name&quot;: &quot;cls&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;这是一个测试项目&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;author&quot;: &quot;xiaochen&quot;, &quot;license&quot;: &quot;ISC&quot;}Is this OK? (yes) yes 对于目前来讲，最有用的是dependencies选项，可以用来帮助我们保存第三方包的依赖信息。 如果node_modules删除了也不用担心，只需要在控制面板中npm install就会自动把package.json中的dependencies中所有的依赖项全部都下载回来。 建议每个项目的根目录下都有一个package.json文件 建议执行npm install 包名的时候都加上--save选项，目的是用来保存依赖信息 package.json和package-lock.jsonnpm 5以前是不会有package-lock.json这个文件 npm5以后才加入这个文件 当你安装包的时候，npm都会生成或者更新package-lock.json这个文件 npm5以后的版本安装都不要加--save参数，它会自动保存依赖信息 当你安装包的时候，会自动创建或者更新package-lock.json文件 package-lock.json这个文件会包含node_modules中所有包的信息（版本，下载地址。。。） 这样的话重新npm install的时候速度就可以提升 从文件来看，有一个lock称之为锁 这个lock使用来锁版本的 如果项目依赖了1.1.1版本 如果你重新install其实会下载最细版本，而不是1.1.1 package-lock.json的另外一个作用就是锁定版本号，防止自动升级 path路径操作模块 参考文档：https://nodejs.org/docs/latest-v13.x/api/path.html path.basename：获取路径的文件名，默认包含扩展名 path.dirname：获取路径中的目录部分 path.extname：获取一个路径中的扩展名部分 path.parse：把路径转换为对象 root：根路径 dir：目录 base：包含后缀名的文件名 ext：后缀名 name：不包含后缀名的文件名 path.join：拼接路径 path.isAbsolute：判断一个路径是否为绝对路径 Node中的其它成员(__dirname,__filename)在每个模块中，除了require,exports等模块相关的API之外，还有两个特殊的成员： __dirname，是一个成员，可以用来动态获取当前文件模块所属目录的绝对路径 __filename，可以用来动态获取当前文件的绝对路径（包含文件名） __dirname和filename是不受执行node命令所属路径影响的 在文件操作中，使用相对路径是不可靠的，因为node中文件操作的路径被设计为相对于执行node命令所处的路径。 所以为了解决这个问题，只需要把相对路径变为绝对路径（绝对路径不受任何影响）就可以了。 就可以使用__dirname或者__filename来帮助我们解决这个问题 在拼接路径的过程中，为了避免手动拼接带来的一些低级错误，推荐使用path.join()来辅助拼接 1234567891011var fs = require('fs');var path = require('path');// console.log(__dirname + 'a.txt');// path.join方法会将文件操作中的相对路径都统一的转为动态的绝对路径fs.readFile(path.join(__dirname + '/a.txt'),'utf8',function(err,data){ if(err){ throw err } console.log(data);}); 补充：模块中的路径标识和这里的路径没关系，不受影响（就是相对于文件模块） 注意： 模块中的路径标识和文件操作中的相对路径标识不一致 模块中的路径标识就是相对于当前文件模块，不受node命令所处路径影响 Express（快速的）作者：Tj 原生的http在某些方面表现不足以应对我们的开发需求，所以就需要使用框架来加快我们的开发效率，框架的目的就是提高效率，让我们的代码高度统一。 在node中有很多web开发框架。主要学习express http://expressjs.com/,其中主要封装的是http。 ```javascript// 1 安装// 2 引包var express = require(‘express’);// 3 创建服务器应用程序// 也就是原来的http.createServer();var app = express(); // 公开指定目录// 只要通过这样做了，就可以通过/public/xx的方式来访问public目录中的所有资源// 在Express中开放资源就是一个API的事app.use(‘/public/‘,express.static(‘/public/‘)); //模板引擎在Express中开放模板也是一个API的事 // 当服务器收到get请求 / 的时候，执行回调处理函数app.get(‘/‘,function(req,res){ res.send('hello express'); }) // 相当于server.listenapp.listen(3000,function(){ console.log('app is runing at port 3000'); }) 12345678910### 学习Express#### 起步##### 安装：```javascriptcnpm install express hello world:1234567891011121314151617181920212223// 引入expressvar express = require('express');// 1. 创建appvar app = express();// 2. app.get('/',function(req,res){ // 1 // res.write('Hello'); // res.write('World'); // res.end() // 2 // res.end('hello world'); // 3 res.send('hello world');})app.listen(3000,function(){ console.log('express app is runing...');}) 基本路由路由： 请求方法 请求路径 请求处理函数 get: 1234//当你以get方法请求/的时候，执行对应的处理函数app.get('/',function(req,res){ res.send('hello world');}) post: 1234//当你以post方法请求/的时候，执行对应的处理函数app.post('/',function(req,res){ res.send('hello world');}) Express静态服务API1234567// app.use不仅仅是用来处理静态资源的，还可以做很多工作(body-parser的配置)app.use(express.static('public'));// 这种方式可以省略请求路径前缀app.use(express.static('files'));// 这种方式相当于static为public目录的别名app.use('/stataic',express.static('public')); 123456789101112131415161718192021222324252627// 引入expressvar express = require('express');// 创建appvar app = express();// 开放静态资源// 1.当以/public/开头的时候，去./public/目录中找对应资源// 访问：http://127.0.0.1:3000/public/login.htmlapp.use('/public/',express.static('./public/')); // 2.当省略第一个参数的时候，可以通过省略/public的方式来访问// 访问：http://127.0.0.1:3000/login.html// app.use(express.static('./public/')); // 3.访问：http://127.0.0.1:3000/a/login.html// a相当于public的别名// app.use('/a/',express.static('./public/')); // app.get('/',function(req,res){ res.end('hello world');});app.listen(3000,function(){ console.log('express app is runing...');}); 在Express中配置使用art-templete模板引擎 art-template官方文档 在node中，有很多第三方模板引擎都可以使用，不是只有art-template 还有ejs，jade（pug），handlebars，nunjucks 安装： 12345npm install --save art-templatenpm install --save express-art-template//两个一起安装npm i --save art-template express-art-template 配置： 1app.engine('html', require('express-art-template')); 使用： 123456app.get('/',function(req,res){ // express默认会去views目录找index.html res.render('index.html',{ title:'hello world' });}) 如果希望修改默认的views视图渲染存储目录，可以： 12// 第一个参数views千万不要写错app.set('views',目录路径); 在Express中获取表单请求数据获取get请求数据：Express内置了一个api，可以直接通过req.query来获取数据 123// 通过requery方法获取用户输入的数据// req.query只能拿到get请求的数据 var comment = req.query; 获取post请求数据：在Express中没有内置获取表单post请求体的api，这里我们需要使用一个第三方包body-parser来获取数据。 安装： 1npm install --save body-parser; 配置： // 配置解析表单 POST 请求体插件（注意：一定要在 app.use(router) 之前 ） 1234567891011121314var express = require('express')// 引包var bodyParser = require('body-parser')var app = express()// 配置body-parser// 只要加入这个配置，则在req请求对象上会多出来一个属性：body// 也就是说可以直接通过req.body来获取表单post请求数据// parse application/x-www-form-urlencodedapp.use(bodyParser.urlencoded({ extended: false }))// parse application/jsonapp.use(bodyParser.json()) 使用： 123456app.use(function (req, res) { res.setHeader('Content-Type', 'text/plain') res.write('you posted:\\n') // 可以通过req.body来获取表单请求数据 res.end(JSON.stringify(req.body, null, 2))}) 在Express中配置使用express-session插件操作 参考文档：https://github.com/expressjs/session 安装： 1npm install express-session 配置： 1234567891011//该插件会为req请求对象添加一个成员:req.session默认是一个对象//这是最简单的配置方式//Session是基于Cookie实现的app.use(session({ //配置加密字符串，他会在原有的基础上和字符串拼接起来去加密 //目的是为了增加安全性，防止客户端恶意伪造 secret: 'keyboard cat', resave: false, saveUninitialized: true,//无论是否适用Session，都默认直接分配一把钥匙 cookie: { secure: true }})) 使用： 123456789101112// 读//添加Session数据//session就是一个对象req.session.foo = 'bar';//写//获取session数据req.session.foo//删req.session.foo = null;delete req.session.foo 提示： 默认Session数据时内存储数据，服务器一旦重启，真正的生产环境会把Session进行持久化存储。 利用Express实现ADUS项目模块化思想模块如何划分: 模块职责要单一 javascript模块化： Node 中的 CommonJS 浏览器中的： AMD require.js CMD sea.js es6中增加了官方支持 起步 初始化 模板处理 路由设计 请求方法 请求路径 get参数 post参数 备注 GET /students 渲染首页 GET /students/new 渲染添加学生页面 POST /students/new name,age,gender,hobbies 处理添加学生请求 GET /students/edit id 渲染编辑页面 POST /students/edit id,name,age,gender,hobbies 处理编辑请求 GET /students/delete id 处理删除请求 提取路由模块router.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * router.js路由模块 * 职责： * 处理路由 * 根据不同的请求方法+请求路径设置具体的请求函数 * 模块职责要单一，我们划分模块的目的就是增强代码的可维护性，提升开发效率 */var fs = require('fs');// Express专门提供了一种更好的方式// 专门用来提供路由的var express = require('express');// 1 创建一个路由容器var router = express.Router();// 2 把路由都挂载到路由容器中router.get('/students', function(req, res) { // res.send('hello world'); // readFile的第二个参数是可选的，传入utf8就是告诉他把读取到的文件直接按照utf8编码，直接转成我们认识的字符 // 除了这样来转换，也可以通过data.toString（）来转换 fs.readFile('./db.json', 'utf8', function(err, data) { if (err) { return res.status(500).send('Server error.') } // 读取到的文件数据是string类型的数据 // console.log(data); // 从文件中读取到的数据一定是字符串，所以一定要手动转换成对象 var students = JSON.parse(data).students; res.render('index.html', { // 读取文件数据 students:students }) })});router.get('/students/new',function(req,res){ res.render('new.html')});router.get('/students/edit',function(req,res){ });router.post('/students/edit',function(req,res){ });router.get('/students/delete',function(req,res){ });// 3 把router导出module.exports = router; app.js: 123456var router = require('./router');// router(app);// 把路由容器挂载到app服务中// 挂载路由app.use(router); 设计操作数据的API文件模块es6中的find和findIndex： find接受一个方法作为参数，方法内部返回一个条件 find会便利所有的元素，执行你给定的带有条件返回值的函数 符合该条件的元素会作为find方法的返回值 如果遍历结束还没有符合该条件的元素，则返回undefined 1234567891011121314151617181920212223242526272829303132333435/** * student.js * 数据操作文件模块 * 职责：操作文件中的数据，只处理数据，不关心业务 */var fs = require('fs'); /** * 获取所有学生列表 * return [] */exports.find = function(){ } /** * 获取添加保存学生 */exports.save = function(){ }/** * 更新学生 */exports.update = function(){ } /** * 删除学生 */exports.delete = function(){ } 步骤 处理模板 配置静态开放资源 配置模板引擎 简单的路由，/studens渲染静态页出来 路由设计 提取路由模块 由于接下来的一系列业务操作都需要处理文件数据，所以我们需要封装Student.js’ 先写好student.js文件结构 查询所有学生列别哦的API findById save updateById deleteById 实现具体功能 通过路由收到请求 接受请求中的参数（get，post） req.query req.body 调用数据操作API处理数据 根据操作结果给客户端发送请求 业务功能顺序 列表 添加 编辑 删除 子模板和模板的继承（模板引擎高级语法）【include，extend，block】注意: 模板页： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;模板页&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/node_modules/bootstrap/dist/css/bootstrap.css&quot;/&gt; {{ block 'head' }}{{ /block }}&lt;/head&gt;&lt;body&gt; &lt;!-- 通过include导入公共部分 --&gt; {{include './header.html'}} &lt;!-- 留一个位置 让别的内容去填充 --&gt; {{ block 'content' }} &lt;h1&gt;默认内容&lt;/h1&gt; {{ /block }} &lt;!-- 通过include导入公共部分 --&gt; {{include './footer.html'}} &lt;!-- 公共样式 --&gt; &lt;script src=&quot;/node_modules/jquery/dist/jquery.js&quot; &gt;&lt;/script&gt; &lt;script src=&quot;/node_modules/bootstrap/dist/js/bootstrap.js&quot; &gt;&lt;/script&gt; {{ block 'script' }}{{ /block }}&lt;/body&gt;&lt;/html&gt; 模板的继承： ​ header页面： 123&lt;div id=&quot;&quot;&gt; &lt;h1&gt;公共的头部&lt;/h1&gt;&lt;/div&gt; ​ footer页面： 123&lt;div id=&quot;&quot;&gt; &lt;h1&gt;公共的底部&lt;/h1&gt;&lt;/div&gt; 模板页的使用： 12345678910111213141516171819202122232425&lt;!-- 继承(extend:延伸，扩展)模板也layout.html --&gt;&lt;!-- 把layout.html页面的内容都拿进来作为index.html页面的内容 --&gt;{{extend './layout.html'}}&lt;!-- 向模板页面填充新的数据 --&gt;&lt;!-- 填充后就会替换掉layout页面content中的数据 --&gt;&lt;!-- style样式方面的内容 --&gt;{{ block 'head' }} &lt;style type=&quot;text/css&quot;&gt; body{ background-color: skyblue; } &lt;/style&gt;{{ /block }}{{ block 'content' }} &lt;div id=&quot;&quot;&gt; &lt;h1&gt;Index页面的内容&lt;/h1&gt; &lt;/div&gt;{{ /block }}&lt;!-- js部分的内容 --&gt;{{ block 'script' }} &lt;script type=&quot;text/javascript&quot;&gt; &lt;/script&gt;{{ /block }} 最终的显示效果： MongoDB关系型和非关系型数据库关系型数据库（表就是关系，或者说表与表之间存在关系）。 所有的关系型数据库都需要通过sql语言来操作 所有的关系型数据库在操作之前都需要设计表结构 而且数据表还支持约束 唯一的 主键 默认值 非空 非关系型数据库 非关系型数据库非常的灵活 有的关系型数据库就是key-value对儿 但MongDB是长得最像关系型数据库的非关系型数据库 数据库 -》 数据库 数据表 -》 集合（数组） 表记录 -》文档对象 一个数据库中可以有多个数据库，一个数据库中可以有多个集合（数组），一个集合中可以有多个文档（表记录） 1234567{ qq:{ user:[ {},{},{}... ] }} 也就是说你可以任意的往里面存数据，没有结构性这么一说 安装 下载 下载地址：https://www.mongodb.com/download-center/community 安装 1npm i mongoose 配置环境变量 最后输入mongod --version测试是否安装成功 启动和关闭数据库启动： 123# mongodb 默认使用执行mongod 命令所处盼复根目录下的/data/db作为自己的数据存储目录# 所以在第一次执行该命令之前先自己手动新建一个 /data/dbmongod 如果想要修改默认的数据存储目录，可以： 1mongod --dbpath = 数据存储目录路径 停止： 12在开启服务的控制台，直接Ctrl+C;或者直接关闭开启服务的控制台。 连接数据库连接： 12# 该命令默认连接本机的 MongoDB 服务mongo 退出： 12# 在连接状态输入 exit 退出连接exit 基本命令 show dbs 查看数据库列表(数据库中的所有数据库) db 查看当前连接的数据库 use 数据库名称 切换到指定的数据库，（如果没有会新建） show collections 查看当前目录下的所有数据表 db.表名.find() 查看表中的详细信息 在Node中如何操作MongoDB数据库使用官方的MongoDB包来操作 ​ http://mongodb.github.io/node-mongodb-native/ 使用第三方包mongoose来操作MongoDB数据库​ 第三方包：mongoose基于MongoDB官方的mongodb包再一次做了封装，名字叫mongoose，是WordPress项目团队开发的。 ​ https://mongoosejs.com/ 学习指南（步骤）官方学习文档：https://mongoosejs.com/docs/index.html 设计Scheme 发布Model (创建表)1234567891011121314151617181920212223242526272829303132333435// 1.引包// 注意：按照后才能require使用var mongoose = require('mongoose');// 拿到schema图表var Schema = mongoose.Schema;// 2.连接数据库// 指定连接数据库后不需要存在，当你插入第一条数据库后会自动创建数据库mongoose.connect('mongodb://localhost/test');// 3.设计集合结构（表结构）// 用户表var userSchema = new Schema({ username: { //姓名 type: String, require: true //添加约束，保证数据的完整性，让数据按规矩统一 }, password: { type: String, require: true }, email: { type: String }});// 4.将文档结构发布为模型// mongoose.model方法就是用来将一个架构发布为 model// 第一个参数：传入一个大写名词单数字符串用来表示你的数据库的名称// mongoose 会自动将大写名词的字符串生成 小写复数 的集合名称// 例如 这里会变成users集合名称// 第二个参数：架构// 返回值：模型构造函数var User = mongoose.model('User', userSchema); 添加数据（增）123456789101112131415// 5.通过模型构造函数对User中的数据进行操作var user = new User({ username: 'admin', password: '123456', email: 'xiaochen@qq.com'});user.save(function(err, ret) { if (err) { console.log('保存失败'); } else { console.log('保存成功'); console.log(ret); }}); 删除（删）根据条件删除所有： 12345678910User.remove({ username: 'xiaoxiao'}, function(err, ret) { if (err) { console.log('删除失败'); } else { console.log('删除成功'); console.log(ret); }}); 根据条件删除一个： 1Model.findOneAndRemove(conditions,[options],[callback]); 根据id删除一个： 1User.findByIdAndRemove(id,[options],[callback]); 更新（改）更新所有： 1User.remove(conditions,doc,[options],[callback]); 根据指定条件更新一个： 1User.FindOneAndUpdate([conditions],[update],[options],[callback]); 根据id更新一个： 12345678910// 更新 根据id来修改表数据User.findByIdAndUpdate('5e6c5264fada77438c45dfcd', { username: 'junjun'}, function(err, ret) { if (err) { console.log('更新失败'); } else { console.log('更新成功'); }}); 查询（查）查询所有： 12345678// 查询所有User.find(function(err,ret){ if(err){ console.log('查询失败'); }else{ console.log(ret); }}); 条件查询所有： 12345678// 根据条件查询User.find({ username:'xiaoxiao' },function(err,ret){ if(err){ console.log('查询失败'); }else{ console.log(ret); }}); 条件查询单个： 1234567891011// 按照条件查询单个，查询出来的数据是一个对象（{}）// 没有条件查询使用findOne方法，查询的是表中的第一条数据User.findOne({ username: 'xiaoxiao'}, function(err, ret) { if (err) { console.log('查询失败'); } else { console.log(ret); }}); 使用Node操作MySQL数据库文档：https://www.npmjs.com/package/mysql 安装： 1npm install --save mysql 1234567891011121314151617181920212223// 引入mysql包var mysql = require('mysql');// 创建连接var connection = mysql.createConnection({ host : 'localhost', //本机 user : 'me', //账号root password : 'secret', //密码12345 database : 'my_db' //数据库名}); // 连接数据库 （打开冰箱门）connection.connect(); //执行数据操作 （把大象放到冰箱）connection.query('SELECT * FROM `users` ', function (error, results, fields) { if (error) throw error;//抛出异常阻止代码往下执行 // 没有异常打印输出结果 console.log('The solution is: ',results);});//关闭连接 （关闭冰箱门）connection.end(); 异步编程回调函数不成立的情况下： 12345678910111213function add(x,y){ console.log(1); setTimeout(function(){ console.log(2); var ret = x + y; return ret; },1000); console.log(3); //到这里执行就结束了，不会i等到前面的定时器，所以直接返回了默认值 undefined}console.log(add(2,2));// 结果是 1 3 undefined 4 使用回调函数解决： 回调函数：通过一个函数，获取函数内部的操作。（根据输入得到输出结果） 12345678910111213141516var ret;function add(x,y,callback){ // callback就是回调函数 // var x = 10; // var y = 20; // var callback = function(ret){console.log(ret);} console.log(1); setTimeout(function(){ var ret = x + y; callback(ret); },1000); console.log(3);}add(10,20,function(ret){ console.log(ret);}); 注意： ​ 凡是需要得到一个函数内部异步操作的结果（setTimeout,readFile,writeFile,ajax,readdir） ​ 这种情况必须通过 回调函数 (异步API都会伴随着一个回调函数) ajax: 基于原生XMLHttpRequest封装get方法： 1234567var oReq = new XMLHttpRequest();// 当请求加载成功要调用指定的函数oReq.onload = function(){ console.log(oReq.responseText);}oReq.open(&quot;GET&quot;, &quot;请求路径&quot;,true);oReq.send(); 12345678910111213function get(url,callback){ var oReq = new XMLHttpRequest(); // 当请求加载成功要调用指定的函数 oReq.onload = function(){ //console.log(oReq.responseText); callback(oReq.responseText); } oReq.open(&quot;GET&quot;, url,true); oReq.send();}get('data.json',function(data){ console.log(data);}); Promisecallback hell（回调地狱）: 文件的读取无法判断执行顺序（文件的执行顺序是依据文件的大小来决定的）(异步api无法保证文件的执行顺序) 12345678910111213141516171819202122232425var fs = require('fs');fs.readFile('./data/a.text','utf8',function(err,data){ if(err){ // 1 读取失败直接打印输出读取失败 return console.log('读取失败'); // 2 抛出异常 // 阻止程序的执行 // 把错误信息打印到控制台 throw err; } console.log(data);});fs.readFile('./data/b.text','utf8',function(err,data){ if(err){ // 1 读取失败直接打印输出读取失败 return console.log('读取失败'); // 2 抛出异常 // 阻止程序的执行 // 把错误信息打印到控制台 throw err; } console.log(data);}); 通过回调嵌套的方式来保证顺序： 1234567891011121314151617181920212223242526272829303132333435var fs = require('fs');fs.readFile('./data/a.text','utf8',function(err,data){ if(err){ // 1 读取失败直接打印输出读取失败 return console.log('读取失败'); // 2 抛出异常 // 阻止程序的执行 // 把错误信息打印到控制台 throw err; } console.log(data); fs.readFile('./data/b.text','utf8',function(err,data){ if(err){ // 1 读取失败直接打印输出读取失败 return console.log('读取失败'); // 2 抛出异常 // 阻止程序的执行 // 把错误信息打印到控制台 throw err; } console.log(data); fs.readFile('./data/a.text','utf8',function(err,data){ if(err){ // 1 读取失败直接打印输出读取失败 return console.log('读取失败'); // 2 抛出异常 // 阻止程序的执行 // 把错误信息打印到控制台 throw err; } console.log(data); }); });}); 为了解决以上编码方式带来的问题（回调地狱嵌套），所以在EcmaScript6新增了一个API:Promise。 Promise：承诺，保证 Promise本身不是异步的，但往往都是内部封装一个异步任务 基本语法： 12345678910111213141516171819202122232425262728// 在EcmaScript 6中新增了一个API Promise// Promise 是一个构造函数var fs = require('fs');// 1 创建Promise容器 resolve:解决 reject：失败var p1 = new Promise(function(resolve, reject) { fs.readFile('./a.text', 'utf8', function(err, data) { if (err) { // console.log(err); // 把容器的Pending状态变为rejected reject(err); } else { // console.log(data); // 把容器的Pending状态变为resolve resolve(1234); } });});// 当p1成功了，然后就（then）做指定的操作// then方法接收的function就是容器中的resolve函数p1 .then(function(data) { console.log(data); }, function(err) { console.log('读取文件失败了', err); }); 链式循环： 封装Promise的readFile： 123456789101112131415161718192021222324252627var fs = require('fs');function pReadFile(filePath) { return new Promise(function(resolve, reject) { fs.readFile(filePath, 'utf8', function(err, data) { if (err) { reject(err); } else { resolve(data); } }); });}pReadFile('./a.txt') .then(function(data) { console.log(data); return pReadFile('./b.txt'); }) .then(function(data) { console.log(data); return pReadFile('./a.txt'); }) .then(function(data) { console.log(data); }) mongoose所有的API都支持Promise： 12345// 查询所有User.find() .then(function(data){ console.log(data) }) 注册： 12345678910111213User.findOne({username:'admin'},function(user){ if(user){ console.log('用户已存在') } else { new User({ username:'aaa', password:'123', email:'fffff' }).save(function(){ console.log('注册成功'); }) }}) 1234567891011121314151617181920User.findOne({ username:'admin'}) .then(function(user){ if(user){ // 用户已经存在不能注册 console.log('用户已存在'); } else{ // 用户不存在可以注册 return new User({ username:'aaa', password:'123', email:'fffff' }).save(); } }) .then(funciton(ret){ console.log('注册成功'); }) Generatorasync函数 其他修改完代码自动重启我们在这里可以使用一个第三方命名行工具：nodemon来帮助我们解决频繁修改代码重启服务器的问题。 nodemon是一个基于Node.js开发的一个第三方命令行工具，我们使用的时候需要独立安装： 1234567#在任意目录执行该命令都可以#也就是说，所有需要 --global安装的包都可以在任意目录执行npm install --global nodemonnpm install -g nodemon#如果安装不成功的话，可以使用cnpm安装cnpm install -g nodemon 安装完毕之后使用： 1234node app.js#使用nodemonnodemon app.js 只要是通过nodemon启动的服务，则他会监视你的文件变化，当文件发生变化的时候，会自动帮你重启服务器。 封装异步API回调函数：获取异步操作的结果 1234567891011function fn(callback){ // var callback = funtion(data){ console.log(data); } setTimeout(function(){ var data = 'hello'; callback(data); },1000);}// 如果需要获取一个函数中异步操作的结果，则必须通过回调函数的方式来获取fn(function(data){ console.log(data);}) 数组的遍历方法，都是对函数作为一种参数EcmaScript 6 参考文档：https://es6.ruanyifeng.com/ 项目案例目录结构12345678910.app.js 项目的入口文件controllersmodels 存储使用mongoose设计的数据模型node_modules 第三方包package.json 包描述文件package-lock.json 第三方包版本锁定文件（npm5之后才有）public 公共静态资源routesviews 存储视图目录 模板页 子模板 模板继承 路由设计 路由 方法 get参数 post参数 是否需要登录 备注 / get 渲染首页 /register(登录) get 渲染注册页面 /register post email,nickname,password 处理注册请求 /login get 渲染登陆界面 /login post email,password 处理登录请求 /loginout get 处理退出请求 模型设计功能实现步骤 创建目录结构 整合静态也-模板页 include block extend 设计用户登陆，退出，注册的路由 用户注册 先处理客户端页面的内容（表单控件的name，收集表单数据，发起请求） 服务端 获取从客户端收到的数据 操作数据库 如果有错，发送500告诉客户端服务器错了‘ 其他的根据业务发送不同的响应数据 登录 退出 Express中间件中间件的概念 参考文档：http://expressjs.com/en/guide/using-middleware.html 中间件：把很复杂的事情分割成单个，然后依次有条理的执行。就是一个中间处理环节，有输入，有输出。 说的通俗易懂点儿，中间件就是一个（从请求到响应调用的方法）方法。 把数据从请求到响应分步骤来处理，每一个步骤都是一个中间处理环节。 123456789101112131415161718192021222324252627var http = require('http');var url = require('url');var cookie = require('./expressPtoject/cookie');var query = require('./expressPtoject/query');var postBody = require('./expressPtoject/post-body');var server = http.createServer(function(){ // 解析请求地址中的get参数 // var obj = url.parse(req.url,true); // req.query = obj.query; query(req,res); //中间件 // 解析请求地址中的post参数 req.body = { foo:'bar' }});if(req.url === 'xxx'){ // 处理请求 ...}server.listen(3000,function(){ console.log('3000 runing...');}); 同一个请求对象所经过的中间件都是同一个请求对象和响应对象。 12345678910111213141516171819202122var express = require('express');var app = express();app.get('/abc',function(req,res,next){ // 同一个请求的req和res是一样的， // 可以前面存储下面调用 console.log('/abc'); // req.foo = 'bar'; req.body = { name:'xiaoxiao', age:18 } next();});app.get('/abc',function(req,res,next){ // console.log(req.foo); console.log(req.body); console.log('/abc');});app.listen(3000, function() { console.log('app is running at port 3000.');}); 中间件的分类:应用程序级别的中间件万能匹配（不关心任何请求路径和请求方法的中间件）： 1234app.use(function(req,res,next){ console.log('Time',Date.now()); next();}); 关心请求路径和请求方法的中间件： 1234app.use('/a',function(req,res,next){ console.log('Time',Date.now()); next();}); 路由级别的中间件严格匹配请求路径和请求方法的中间件 get: 123app.get('/',function(req,res){ res.send('get');}); post： 123app.post('/a',function(req,res){ res.send('post');}); put: 123app.put('/user',function(req,res){ res.send('put');}); delete: 123app.delete('/delete',function(req,res){ res.send('delete');}); 总12345678910111213141516171819202122232425262728293031323334353637383940414243var express = require('express');var app = express();// 中间件：处理请求，本质就是个函数// 在express中，对中间件有几种分类// 1 不关心任何请求路径和请求方法的中间件// 也就是说任何请求都会进入这个中间件// 中间件本身是一个方法，该方法接收三个参数// Request 请求对象// Response 响应对象// next 下一个中间件// // 全局匹配中间件// app.use(function(req, res, next) {// console.log('1');// // 当一个请求进入中间件后// // 如果需要请求另外一个方法则需要使用next（）方法// next();// // next是一个方法，用来调用下一个中间件// // 注意：next（）方法调用下一个方法的时候，也会匹配（不是调用紧挨着的哪一个）// });// app.use(function(req, res, next) {// console.log('2');// });// // 2 关心请求路径的中间件// // 以/xxx开头的中间件// app.use('/a',function(req, res, next) {// console.log(req.url);// });// 3 严格匹配请求方法和请求路径的中间件app.get('/',function(){ console.log('/');});app.post('/a',function(){ console.log('/a');});app.listen(3000, function() { console.log('app is running at port 3000.');}); 错误处理中间件1234app.use(function(err,req,res,next){ console.error(err,stack); res.status(500).send('Something broke');}); 配置使用404中间件： 123app.use(function(req,res){ res.render('404.html');}); 配置全局错误处理中间件: 1234567891011121314151617app.get('/a', function(req, res, next) { fs.readFile('.a/bc', funtion() { if (err) { // 当调用next()传参后，则直接进入到全局错误处理中间件方法中 // 当发生全局错误的时候，我们可以调用next传递错误对象 // 然后被全局错误处理中间件匹配到并进行处理 next(err); } })});//全局错误处理中间件app.use(function(err,req,res,next){ res.status(500).json({ err_code:500, message:err.message });}); 内置中间件 express.static(提供静态文件) http://expressjs.com/en/starter/static-files.html#serving-static-files-in-express 第三方中间件 参考文档：http://expressjs.com/en/resources/middleware.html body-parser compression cookie-parser mogran response-time server-static session .post-primary{ display: none; }","link":"/2020/05/10/node-note/"},{"title":"Vue 笔记 Day1","text":"黑马的课堂笔记总结，总共五天。附上Vue生命周期图 Day1 # Vue.js - Day1 课程介绍前5天： 都在学习Vue基本的语法和概念；打包工具 Webpack , Gulp后5天： 以项目驱动教学； 什么是Vue.js Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果； 为什么要学习流行框架 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱； 企业中，使用框架，能够提高开发的效率； 提高开发效率的发展历程：原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】） 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑； 增强自己就业时候的竞争力 人无我有，人有我优 你平时不忙的时候，都在干嘛？ 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel 为什么有了MVC还要有MVVM Vue.js 基本代码 和 MVVM 之间的对应关系Vue之 - 基本的代码结构和插值表达式、v-cloakVue指令之v-text和v-htmlVue指令之v-bind的三种用法 直接使用指令v-bind 使用简化指令: 在绑定的时候，拼接绑定内容：:title=&quot;btnTitle + ', 这是追加的内容'&quot; Vue指令之v-on和跑马灯效果跑马灯效果 HTML结构： 1234567891011&lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{info}}&lt;/p&gt; &lt;input type=&quot;button&quot; value=&quot;开启&quot; v-on:click=&quot;go&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;停止&quot; v-on:click=&quot;stop&quot;&gt; &lt;/div&gt; Vue实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { info: '猥琐发育，别浪~！', intervalId: null }, methods: { go() { // 如果当前有定时器在运行，则直接return if (this.intervalId != null) { return; } // 开始定时器 this.intervalId = setInterval(() =&gt; { this.info = this.info.substring(1) + this.info.substring(0, 1); }, 500); }, stop() { clearInterval(this.intervalId); } } }); Vue指令之v-on的缩写和事件修饰符事件修饰符： .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 Vue指令之v-model和双向数据绑定简易计算器案例 HTML 代码结构 12345678910111213141516171819202122232425&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;n1&quot;&gt; &lt;select v-model=&quot;opt&quot;&gt; &lt;option value=&quot;0&quot;&gt;+&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;-&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;*&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;÷&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;text&quot; v-model=&quot;n2&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;=&quot; v-on:click=&quot;getResult&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;result&quot;&gt;&lt;/div&gt; Vue实例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { n1: 0, n2: 0, result: 0, opt: '0' }, methods: { getResult() { switch (this.opt) { case '0': this.result = parseInt(this.n1) + parseInt(this.n2); break; case '1': this.result = parseInt(this.n1) - parseInt(this.n2); break; case '2': this.result = parseInt(this.n1) * parseInt(this.n2); break; case '3': this.result = parseInt(this.n1) / parseInt(this.n2); break; } } } }); 在Vue中使用样式使用class样式 数组 1&lt;h1 :class=&quot;['red', 'thin']&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中使用三元表达式 1&lt;h1 :class=&quot;['red', 'thin', isactive?'active':'']&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中嵌套对象 1&lt;h1 :class=&quot;['red', 'thin', {'active': isactive}]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 直接使用对象 1&lt;h1 :class=&quot;{red:true, italic:true, active:true, thin:true}&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 使用内联样式 直接在元素上通过 :style 的形式，书写样式对象 1&lt;h1 :style=&quot;{color: 'red', 'font-size': '40px'}&quot;&gt;这是一个善良的H1&lt;/h1&gt; 将样式对象，定义到 data 中，并直接引用到 :style 中 在data上定义样式：123data: { h1StyleObj: { color: 'red', 'font-size': '40px', 'font-weight': '200' }} 在元素中，通过属性绑定的形式，将样式对象应用到元素中：1&lt;h1 :style=&quot;h1StyleObj&quot;&gt;这是一个善良的H1&lt;/h1&gt; 在 :style 中通过数组，引用多个 data 上的样式对象 在data上定义样式：1234data: { h1StyleObj: { color: 'red', 'font-size': '40px', 'font-weight': '200' }, h1StyleObj2: { fontStyle: 'italic' }} 在元素中，通过属性绑定的形式，将样式对象应用到元素中：1&lt;h1 :style=&quot;[h1StyleObj, h1StyleObj2]&quot;&gt;这是一个善良的H1&lt;/h1&gt; Vue指令之v-for和key属性 迭代数组 123&lt;ul&gt; &lt;li v-for=&quot;(item, i) in list&quot;&gt;索引：{{i}} --- 姓名：{{item.name}} --- 年龄：{{item.age}}&lt;/li&gt;&lt;/ul&gt; 迭代对象中的属性 12345&lt;!-- 循环遍历对象身上的属性 --&gt; &lt;div v-for=&quot;(val, key, i) in userInfo&quot;&gt;{{val}} --- {{key}} --- {{i}}&lt;/div&gt; 迭代数字 123&lt;p v-for=&quot;i in 10&quot;&gt;这是第 {{i}} 个P标签&lt;/p&gt; 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 Vue指令之v-if和v-show 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。 品牌管理案例添加新品牌删除品牌根据条件筛选品牌 1.x 版本中的filterBy指令，在2.x中已经被废除： filterBy - 指令 1234567891011121314151617&lt;tr v-for=&quot;item in list | filterBy searchName in 'name'&quot;&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.ctime}}&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 12345&lt;hr&gt; 输入筛选名称：&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot;&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 123456789101112131415161718192021&lt;tbody&gt; &lt;tr v-for=&quot;item in search(searchName)&quot;&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.ctime}}&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 1234567891011search(name) { return this.list.filter(x =&gt; { return x.name.indexOf(name) != -1; });} Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 私有过滤器 HTML元素： 123&lt;td&gt;{{item.ctime | dataFormat('yyyy-mm-dd')}}&lt;/td&gt; 私有 filters 定义方式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445filters: { // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = &quot;&quot;) { // 在参数列表中 通过 pattern=&quot;&quot; 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') { return `${y}-${m}-${d}`; } else { // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `${y}-${m}-${d} ${hh}:${mm}:${ss}`; } } } 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器12345678910111213141516171819202122232425262728293031323334353637383940414243// 定义一个全局过滤器Vue.filter('dataFormat', function (input, pattern = '') { var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') { return `${y}-${m}-${d}`; } else { // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `${y}-${m}-${d} ${hh}:${mm}:${ss}`; }}); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 键盘修饰符以及自定义键盘修饰符1.x中自定义键盘修饰符【了解即可】123Vue.directive('on').keyCodes.f2 = 113; 2.x中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： 123Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： 123&lt;input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.f2=&quot;add&quot;&gt; 自定义指令 自定义全局和局部的 自定义指令： 12345678910111213141516171819202122232425262728293031323334353637// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：Vue.directive('focus', { inserted: function (el) { // inserted 表示被绑定元素插入父节点时调用 el.focus(); }});// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: { color: { // 为元素设置指定的字体颜色 bind(el, binding) { el.style.color = binding.value; } }, 'font-weight': function (el, binding2) { // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; } } 自定义指令的使用方式： 123&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot; v-focus v-color=&quot;'red'&quot; v-font-weight=&quot;900&quot;&gt; Vue 1.x 中 自定义元素指令【已废弃,了解即可】12345Vue.elementDirective('red-color', { bind: function () { this.el.style.color = 'red'; }}); 使用方式： 1&lt;red-color&gt;1232&lt;/red-color&gt; 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 Vue.js双向绑定的实现原理 Day2 # Vue.js - Day2 品牌管理案例添加新品牌删除品牌根据条件筛选品牌 1.x 版本中的filterBy指令，在2.x中已经被废除： filterBy - 指令 1234567891011121314151617&lt;tr v-for=&quot;item in list | filterBy searchName in 'name'&quot;&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.ctime}}&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 12345&lt;hr&gt; 输入筛选名称：&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot;&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 123456789101112131415161718192021&lt;tbody&gt; &lt;tr v-for=&quot;item in search(searchName)&quot;&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.ctime}}&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 1234567891011search(name) { return this.list.filter(x =&gt; { return x.name.indexOf(name) != -1; });} Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 私有过滤器 HTML元素： 123&lt;td&gt;{{item.ctime | dataFormat('yyyy-mm-dd')}}&lt;/td&gt; 私有 filters 定义方式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445filters: { // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = &quot;&quot;) { // 在参数列表中 通过 pattern=&quot;&quot; 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') { return `${y}-${m}-${d}`; } else { // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `${y}-${m}-${d} ${hh}:${mm}:${ss}`; } } } 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器12345678910111213141516171819202122232425262728293031323334353637383940414243// 定义一个全局过滤器Vue.filter('dataFormat', function (input, pattern = '') { var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') { return `${y}-${m}-${d}`; } else { // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `${y}-${m}-${d} ${hh}:${mm}:${ss}`; }}); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 键盘修饰符以及自定义键盘修饰符1.x中自定义键盘修饰符【了解即可】123Vue.directive('on').keyCodes.f2 = 113; 2.x中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： 123Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： 123&lt;input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.f2=&quot;add&quot;&gt; 自定义指令 自定义全局和局部的 自定义指令： 12345678910111213141516171819202122232425262728293031323334353637// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：Vue.directive('focus', { inserted: function (el) { // inserted 表示被绑定元素插入父节点时调用 el.focus(); }});// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: { color: { // 为元素设置指定的字体颜色 bind(el, binding) { el.style.color = binding.value; } }, 'font-weight': function (el, binding2) { // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; } } 自定义指令的使用方式： 123&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot; v-focus v-color=&quot;'red'&quot; v-font-weight=&quot;900&quot;&gt; Vue 1.x 中 自定义元素指令【已废弃,了解即可】12345Vue.elementDirective('red-color', { bind: function () { this.el.style.color = 'red'; }}); 使用方式： 1&lt;red-color&gt;1232&lt;/red-color&gt; vue实例的生命周期 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 vue-resource 实现 get, post, jsonp请求除了 vue-resource 之外，还可以使用 axios 的第三方包实现实现数据的请求 之前的学习中，如何发起数据请求？ 常见的数据请求类型？ get post jsonp 测试的URL请求资源地址： get请求地址： http://vue.studyit.io/api/getlunbo post请求地址：http://vue.studyit.io/api/post jsonp请求地址：http://vue.studyit.io/api/jsonp JSONP的实现原理 由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全； 可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）； 具体实现过程： 先在客户端定义一个回调方法，预定义对数据的操作； 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口； 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了； 带大家通过 Node.js ，来手动实现一个JSONP的请求例子； 1234567891011121314151617181920212223242526272829303132333435const http = require('http');// 导入解析 URL 地址的核心模块const urlModule = require('url');const server = http.createServer();// 监听 服务器的 request 请求事件，处理每个请求server.on('request', (req, res) =&gt; { const url = req.url; // 解析客户端请求的URL地址 var info = urlModule.parse(url, true); // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据 if (info.pathname === '/getjsonp') { // 获取客户端指定的回调函数的名称 var cbName = info.query.callback; // 手动拼接要返回给客户端的数据对象 var data = { name: 'zs', age: 22, gender: '男', hobby: ['吃饭', '睡觉', '运动'] } // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法： var result = `${cbName}(${JSON.stringify(data)})`; // 将拼接好的方法的调用，返回给客户端去解析执行 res.end(result); } else { res.end('404'); }});server.listen(3000, () =&gt; { console.log('server running at http://127.0.0.1:3000');}); vue-resource 的配置步骤： 直接在页面中，通过script标签，引入 vue-resource 的脚本文件； 注意：引用的先后顺序是：先引用 Vue 的脚本文件，再引用 vue-resource 的脚本文件； 发送get请求：12345getInfo() { // get 方式获取数据 this.$http.get('http://127.0.0.1:8899/api/getlunbo').then(res =&gt; { console.log(res.body); })} 发送post请求：12345678910postInfo() { var url = 'http://127.0.0.1:8899/api/post'; // post 方法接收三个参数： // 参数1： 要请求的URL地址 // 参数2： 要发送的数据对象 // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded this.$http.post(url, { name: 'zs' }, { emulateJSON: true }).then(res =&gt; { console.log(res.body); });} 发送JSONP请求获取数据：123456jsonpInfo() { // JSONP形式从服务器获取数据 var url = 'http://127.0.0.1:8899/api/jsonp'; this.$http.jsonp(url).then(res =&gt; { console.log(res.body); });} 配置本地数据库和数据接口API 先解压安装 PHPStudy; 解压安装 Navicat 这个数据库可视化工具，并激活； 打开 Navicat 工具，新建空白数据库，名为 dtcmsdb4; 双击新建的数据库，连接上这个空白数据库，在新建的数据库上右键 -&gt; 运行SQL文件，选择并执行 dtcmsdb4.sql 这个数据库脚本文件；如果执行不报错，则数据库导入完成； 进入文件夹 vuecms3_nodejsapi 内部，执行 npm i 安装所有的依赖项； 先确保本机安装了 nodemon, 没有安装，则运行 npm i nodemon -g 进行全局安装，安装完毕后，进入到 vuecms3_nodejsapi目录 -&gt; src目录 -&gt; 双击运行 start.bat 如果API启动失败，请检查 PHPStudy 是否正常开启，同时，检查 app.js 中第 14行 中数据库连接配置字符串是否正确；PHPStudy 中默认的 用户名是root，默认的密码也是root 品牌管理改造展示品牌列表添加品牌数据删除品牌数据Vue中的动画为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能； 使用过渡类名 HTML结构：1234567&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;动起来&quot; @click=&quot;myAnimate&quot;&gt; &lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;div v-show=&quot;isshow&quot;&gt;动画哦&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; VM 实例：123456789101112// 创建 Vue 实例，得到 ViewModelvar vm = new Vue({ el: '#app', data: { isshow: false }, methods: { myAnimate() { this.isshow = !this.isshow; } }}); 定义两组类样式：12345678910111213/* 定义进入和离开时候的过渡状态 */ .fade-enter-active, .fade-leave-active { transition: all 0.2s ease; position: absolute; } /* 定义进入过渡的开始状态 和 离开过渡的结束状态 */ .fade-enter, .fade-leave-to { opacity: 0; transform: translateX(100px); } 使用第三方 CSS 动画库 导入动画类库：1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./lib/animate.css&quot;&gt; 定义 transition 及属性：123456&lt;transition enter-active-class=&quot;fadeInRight&quot; leave-active-class=&quot;fadeOutRight&quot; :duration=&quot;{ enter: 500, leave: 800 }&quot;&gt; &lt;div class=&quot;animated&quot; v-show=&quot;isshow&quot;&gt;动画哦&lt;/div&gt;&lt;/transition&gt; 使用动画钩子函数 定义 transition 组件以及三个钩子函数：123456789&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;切换动画&quot; @click=&quot;isshow = !isshow&quot;&gt; &lt;transition @before-enter=&quot;beforeEnter&quot; @enter=&quot;enter&quot; @after-enter=&quot;afterEnter&quot;&gt; &lt;div v-if=&quot;isshow&quot; class=&quot;show&quot;&gt;OK&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; 定义三个 methods 钩子方法：12345678910111213methods: { beforeEnter(el) { // 动画进入之前的回调 el.style.transform = 'translateX(500px)'; }, enter(el, done) { // 动画进入完成时候的回调 el.offsetWidth; el.style.transform = 'translateX(0px)'; done(); }, afterEnter(el) { // 动画进入完成之后的回调 this.isshow = !this.isshow; } } 定义动画过渡时长和样式：123.show{ transition: all 0.4s ease; } v-for 的列表过渡 定义过渡样式：123456789101112&lt;style&gt; .list-enter, .list-leave-to { opacity: 0; transform: translateY(10px); } .list-enter-active, .list-leave-active { transition: all 0.3s ease; }&lt;/style&gt; 定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来：1234567&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;txt&quot; @keyup.enter=&quot;add&quot;&gt; &lt;transition-group tag=&quot;ul&quot; name=&quot;list&quot;&gt; &lt;li v-for=&quot;(item, i) in list&quot; :key=&quot;i&quot;&gt;{{item}}&lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt; 定义 VM中的结构：1234567891011121314// 创建 Vue 实例，得到 ViewModelvar vm = new Vue({ el: '#app', data: { txt: '', list: [1, 2, 3, 4] }, methods: { add() { this.list.push(this.txt); this.txt = ''; } }}); 列表的排序过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。 v-move 和 v-leave-active 结合使用，能够让列表的过渡更加平缓柔和：123456.v-move{ transition: all 0.8s ease;}.v-leave-active{ position: absolute;} 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 pagekit/vue-resource navicat如何导入sql文件和导出sql文件 贝塞尔在线生成器 Day3 # Vue.js - Day3 定义Vue组件什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；组件化和模块化的不同： 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一； 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；全局组件定义的三种方式 使用 Vue.extend 配合 Vue.component 方法：1234var login = Vue.extend({ template: '&lt;h1&gt;登录&lt;/h1&gt;' }); Vue.component('login', login); 直接使用 Vue.component 方法：123Vue.component('register', { template: '&lt;h1&gt;注册&lt;/h1&gt;' }); 将模板字符串，定义到script标签种：123&lt;script id=&quot;tmpl&quot; type=&quot;x-template&quot;&gt; &lt;div&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;&lt;/div&gt; &lt;/script&gt; 同时，需要使用 Vue.component 来定义组件：123Vue.component('account', { template: '#tmpl' }); 注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！ 组件中展示数据和响应事件 在组件中，data需要被定义为一个方法，例如：12345678910111213Vue.component('account', { template: '#tmpl', data() { return { msg: '大家好！' } }, methods:{ login(){ alert('点击了登录按钮'); } } }); 在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的data属性中的值，需要使用this来访问； 【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象 通过计数器案例演示 使用components属性定义局部子组件 组件实例定义方式：123456789101112131415161718&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: {}, components: { // 定义子组件 account: { // account 组件 template: '&lt;div&gt;&lt;h1&gt;这是Account组件{{name}}&lt;/h1&gt;&lt;login&gt;&lt;/login&gt;&lt;/div&gt;', // 在这里使用定义的子组件 components: { // 定义子组件的子组件 login: { // login 组件 template: &quot;&lt;h3&gt;这是登录组件&lt;/h3&gt;&quot; } } } } }); &lt;/script&gt; 引用组件：123&lt;div id=&quot;app&quot;&gt; &lt;account&gt;&lt;/account&gt; &lt;/div&gt; 使用flag标识符结合v-if和v-else切换组件 页面结构：12345&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;&gt; &lt;my-com1 v-if=&quot;flag&quot;&gt;&lt;/my-com1&gt; &lt;my-com2 v-else=&quot;flag&quot;&gt;&lt;/my-com2&gt; &lt;/div&gt; Vue实例定义：123456789101112131415161718&lt;script&gt; Vue.component('myCom1', { template: '&lt;h3&gt;奔波霸&lt;/h3&gt;' }) Vue.component('myCom2', { template: '&lt;h3&gt;霸波奔&lt;/h3&gt;' }) // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { flag: true }, methods: {} }); &lt;/script&gt; 使用:is属性来切换不同的子组件,并添加切换动画 组件实例定义方式：12345678910111213141516171819202122// 登录组件 const login = Vue.extend({ template: `&lt;div&gt; &lt;h3&gt;登录组件&lt;/h3&gt; &lt;/div&gt;` }); Vue.component('login', login); // 注册组件 const register = Vue.extend({ template: `&lt;div&gt; &lt;h3&gt;注册组件&lt;/h3&gt; &lt;/div&gt;` }); Vue.component('register', register); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { comName: 'login' }, methods: {} }); 使用component标签，来引用组件，并通过:is属性来指定要加载的组件：12345678&lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;comName='login'&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;comName='register'&quot;&gt;注册&lt;/a&gt; &lt;hr&gt; &lt;transition mode=&quot;out-in&quot;&gt; &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt; &lt;/transition&gt;&lt;/div&gt; 添加切换样式：1234567891011121314151617&lt;style&gt; .v-enter, .v-leave-to { opacity: 0; transform: translateX(30px); } .v-enter-active, .v-leave-active { position: absolute; transition: all 0.3s ease; } h3{ margin: 0; }&lt;/style&gt; 父组件向子组件传值 组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据123456789101112131415&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { msg: '这是父组件中的消息' }, components: { son: { template: '&lt;h1&gt;这是子组件 --- {{finfo}}&lt;/h1&gt;', props: ['finfo'] } } }); &lt;/script&gt; 使用v-bind或简化指令，将数据传递到子组件中：123&lt;div id=&quot;app&quot;&gt; &lt;son :finfo=&quot;msg&quot;&gt;&lt;/son&gt; &lt;/div&gt; 子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称1&lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt; 子组件内部通过this.$emit('方法名', 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用12345678910111213141516171819202122232425262728293031323334&lt;div id=&quot;app&quot;&gt; &lt;!-- 引用父组件 --&gt; &lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt; &lt;!-- 组件模板定义 --&gt; &lt;script type=&quot;x-template&quot; id=&quot;son&quot;&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;向父组件传值&quot; @click=&quot;sendMsg&quot; /&gt; &lt;/div&gt; &lt;/script&gt; &lt;/div&gt; &lt;script&gt; // 子组件的定义方式 Vue.component('son', { template: '#son', // 组件模板Id methods: { sendMsg() { // 按钮的点击事件 this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去 } } }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: { getMsg(val){ // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义 alert(val); } } }); &lt;/script&gt; 评论列表案例目标：主要练习父子组件之间传值 使用 this.$refs 来获取元素和组件123456789101112131415161718192021222324252627282930313233343536&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;获取元素内容&quot; @click=&quot;getElement&quot; /&gt; &lt;!-- 使用 ref 获取元素 --&gt; &lt;h1 ref=&quot;myh1&quot;&gt;这是一个大大的H1&lt;/h1&gt; &lt;hr&gt; &lt;!-- 使用 ref 获取子组件 --&gt; &lt;my-com ref=&quot;mycom&quot;&gt;&lt;/my-com&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-com', { template: '&lt;h5&gt;这是一个子组件&lt;/h5&gt;', data() { return { name: '子组件' } } }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: { getElement() { // 通过 this.$refs 来获取元素 console.log(this.$refs.myh1.innerText); // 通过 this.$refs 来获取组件 console.log(this.$refs.mycom.name); } } });&lt;/script&gt; 什么是路由 对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； 在 vue 中使用 vue-router 导入 vue-router 组件类库：12&lt;!-- 1. 导入 vue-router 组件类库 --&gt; &lt;script src=&quot;./lib/vue-router-2.7.0.js&quot;&gt;&lt;/script&gt; 使用 router-link 组件来导航123&lt;!-- 2. 使用 router-link 组件来导航 --&gt;&lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; 使用 router-view 组件来显示匹配到的组件12&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 创建使用Vue.extend创建组件123456789// 4.1 使用 Vue.extend 来创建登录组件var login = Vue.extend({ template: '&lt;h1&gt;登录组件&lt;/h1&gt;'});// 4.2 使用 Vue.extend 来创建注册组件var register = Vue.extend({ template: '&lt;h1&gt;注册组件&lt;/h1&gt;'}); 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则1234567// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 var router = new VueRouter({ routes: [ { path: '/login', component: login }, { path: '/register', component: register } ] }); 使用 router 属性来使用路由规则12345// 6. 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', router: router // 使用 router 属性来使用路由规则 }); 设置路由高亮设置路由切换动效在路由规则中定义参数 在规则中定义参数：1{ path: '/register/:id', component: register } 通过 this.$route.params来获取路由中的参数：123var register = Vue.extend({ template: '&lt;h1&gt;注册组件 --- {{this.$route.params.id}}&lt;/h1&gt;' }); 使用 children 属性实现路由嵌套1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/account&quot;&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; // 父路由中的组件 const account = Vue.extend({ template: `&lt;div&gt; 这是account组件 &lt;router-link to=&quot;/account/login&quot;&gt;login&lt;/router-link&gt; | &lt;router-link to=&quot;/account/register&quot;&gt;register&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;` }); // 子路由中的 login 组件 const login = Vue.extend({ template: '&lt;div&gt;登录组件&lt;/div&gt;' }); // 子路由中的 register 组件 const register = Vue.extend({ template: '&lt;div&gt;注册组件&lt;/div&gt;' }); // 路由实例 var router = new VueRouter({ routes: [ { path: '/', redirect: '/account/login' }, // 使用 redirect 实现路由重定向 { path: '/account', component: account, children: [ // 通过 children 数组属性，来实现路由的嵌套 { path: 'login', component: login }, // 注意，子路由的开头位置，不要加 / 路径符 { path: 'register', component: register } ] } ] }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: {}, components: { account }, router: router });&lt;/script&gt; 命名视图实现经典布局 标签代码结构：1234567&lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class=&quot;content&quot;&gt; &lt;router-view name=&quot;a&quot;&gt;&lt;/router-view&gt; &lt;router-view name=&quot;b&quot;&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; JS代码：12345678910111213141516171819202122232425262728293031323334&lt;script&gt; var header = Vue.component('header', { template: '&lt;div class=&quot;header&quot;&gt;header&lt;/div&gt;' }); var sidebar = Vue.component('sidebar', { template: '&lt;div class=&quot;sidebar&quot;&gt;sidebar&lt;/div&gt;' }); var mainbox = Vue.component('mainbox', { template: '&lt;div class=&quot;mainbox&quot;&gt;mainbox&lt;/div&gt;' }); // 创建路由对象 var router = new VueRouter({ routes: [ { path: '/', components: { default: header, a: sidebar, b: mainbox } } ] }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: {}, router }); &lt;/script&gt; CSS 样式：12345678910111213141516171819&lt;style&gt; .header { border: 1px solid red; } .content{ display: flex; } .sidebar { flex: 2; border: 1px solid green; height: 500px; } .mainbox{ flex: 8; border: 1px solid blue; height: 500px; }&lt;/style&gt; watch属性的使用考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？） 监听data中属性的改变：1234567891011121314151617181920212223242526&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; = &lt;span&gt;{{fullName}}&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { firstName: 'jack', lastName: 'chen', fullName: 'jack - chen' }, methods: {}, watch: { 'firstName': function (newVal, oldVal) { // 第一个参数是新数据，第二个参数是旧数据 this.fullName = newVal + ' - ' + this.lastName; }, 'lastName': function (newVal, oldVal) { this.fullName = this.firstName + ' - ' + newVal; } } }); &lt;/script&gt; 监听路由对象的改变：1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = Vue.extend({ template: '&lt;h1&gt;登录组件&lt;/h1&gt;' }); var register = Vue.extend({ template: '&lt;h1&gt;注册组件&lt;/h1&gt;' }); var router = new VueRouter({ routes: [ { path: &quot;/login&quot;, component: login }, { path: &quot;/register&quot;, component: register } ] }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: {}, router: router, watch: { '$route': function (newVal, oldVal) { if (newVal.path === '/login') { console.log('这是登录组件'); } } } }); &lt;/script&gt; computed计算属性的使用 默认只有getter的计算属性：12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; = &lt;span&gt;{{fullName}}&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { firstName: 'jack', lastName: 'chen' }, methods: {}, computed: { // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值 fullName() { return this.firstName + ' - ' + this.lastName; } } }); &lt;/script&gt; 定义有getter和setter的计算属性：123456789101112131415161718192021222324252627282930313233343536&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt; &lt;input type=&quot;button&quot; value=&quot;修改fullName&quot; @click=&quot;changeName&quot;&gt; &lt;span&gt;{{fullName}}&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { firstName: 'jack', lastName: 'chen' }, methods: { changeName() { this.fullName = 'TOM - chen2'; } }, computed: { fullName: { get: function () { return this.firstName + ' - ' + this.lastName; }, set: function (newVal) { var parts = newVal.split(' - '); this.firstName = parts[0]; this.lastName = parts[1]; } } } }); &lt;/script&gt; watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； nrm的安装使用作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样； 运行npm i nrm -g全局安装nrm包； 使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 使用nrm use npm或nrm use taobao切换不同的镜像源地址； 相关文件 URL中的hash（井号） Day4 # Vue.js - Day4 父组件向子组件传值 组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据123456789101112131415&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { msg: '这是父组件中的消息' }, components: { son: { template: '&lt;h1&gt;这是子组件 --- {{finfo}}&lt;/h1&gt;', props: ['finfo'] } } }); &lt;/script&gt; 使用v-bind或简化指令，将数据传递到子组件中：123&lt;div id=&quot;app&quot;&gt; &lt;son :finfo=&quot;msg&quot;&gt;&lt;/son&gt; &lt;/div&gt; 子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称1&lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt; 子组件内部通过this.$emit('方法名', 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用12345678910111213141516171819202122232425262728293031323334&lt;div id=&quot;app&quot;&gt; &lt;!-- 引用父组件 --&gt; &lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt; &lt;!-- 组件模板定义 --&gt; &lt;script type=&quot;x-template&quot; id=&quot;son&quot;&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;向父组件传值&quot; @click=&quot;sendMsg&quot; /&gt; &lt;/div&gt; &lt;/script&gt; &lt;/div&gt; &lt;script&gt; // 子组件的定义方式 Vue.component('son', { template: '#son', // 组件模板Id methods: { sendMsg() { // 按钮的点击事件 this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去 } } }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: { getMsg(val){ // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义 alert(val); } } }); &lt;/script&gt; 组件中data和props的区别评论列表案例目标：主要练习父子组件之间传值 使用 this.$refs 来获取元素和组件123456789101112131415161718192021222324252627282930313233343536&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;获取元素内容&quot; @click=&quot;getElement&quot; /&gt; &lt;!-- 使用 ref 获取元素 --&gt; &lt;h1 ref=&quot;myh1&quot;&gt;这是一个大大的H1&lt;/h1&gt; &lt;hr&gt; &lt;!-- 使用 ref 获取子组件 --&gt; &lt;my-com ref=&quot;mycom&quot;&gt;&lt;/my-com&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-com', { template: '&lt;h5&gt;这是一个子组件&lt;/h5&gt;', data() { return { name: '子组件' } } }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: { getElement() { // 通过 this.$refs 来获取元素 console.log(this.$refs.myh1.innerText); // 通过 this.$refs 来获取组件 console.log(this.$refs.mycom.name); } } });&lt;/script&gt; 什么是路由 后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； 在 vue 中使用 vue-router 导入 vue-router 组件类库：12&lt;!-- 1. 导入 vue-router 组件类库 --&gt; &lt;script src=&quot;./lib/vue-router-2.7.0.js&quot;&gt;&lt;/script&gt; 使用 router-link 组件来导航123&lt;!-- 2. 使用 router-link 组件来导航 --&gt;&lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; 使用 router-view 组件来显示匹配到的组件12&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 创建使用Vue.extend创建组件123456789// 4.1 使用 Vue.extend 来创建登录组件var login = Vue.extend({ template: '&lt;h1&gt;登录组件&lt;/h1&gt;'});// 4.2 使用 Vue.extend 来创建注册组件var register = Vue.extend({ template: '&lt;h1&gt;注册组件&lt;/h1&gt;'}); 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则1234567// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 var router = new VueRouter({ routes: [ { path: '/login', component: login }, { path: '/register', component: register } ] }); 使用 router 属性来使用路由规则12345// 6. 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', router: router // 使用 router 属性来使用路由规则 }); 使用tag属性指定router-link渲染的标签类型设置路由重定向设置路由高亮设置路由切换动效在路由规则中定义参数 在规则中定义参数：1{ path: '/register/:id', component: register } 通过 this.$route.params来获取路由中的参数：123var register = Vue.extend({ template: '&lt;h1&gt;注册组件 --- {{this.$route.params.id}}&lt;/h1&gt;' }); 使用 children 属性实现路由嵌套1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/account&quot;&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; // 父路由中的组件 const account = Vue.extend({ template: `&lt;div&gt; 这是account组件 &lt;router-link to=&quot;/account/login&quot;&gt;login&lt;/router-link&gt; | &lt;router-link to=&quot;/account/register&quot;&gt;register&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;` }); // 子路由中的 login 组件 const login = Vue.extend({ template: '&lt;div&gt;登录组件&lt;/div&gt;' }); // 子路由中的 register 组件 const register = Vue.extend({ template: '&lt;div&gt;注册组件&lt;/div&gt;' }); // 路由实例 var router = new VueRouter({ routes: [ { path: '/', redirect: '/account/login' }, // 使用 redirect 实现路由重定向 { path: '/account', component: account, children: [ // 通过 children 数组属性，来实现路由的嵌套 { path: 'login', component: login }, // 注意，子路由的开头位置，不要加 / 路径符 { path: 'register', component: register } ] } ] }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: {}, components: { account }, router: router });&lt;/script&gt; 命名视图实现经典布局 标签代码结构：1234567&lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class=&quot;content&quot;&gt; &lt;router-view name=&quot;a&quot;&gt;&lt;/router-view&gt; &lt;router-view name=&quot;b&quot;&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; JS代码：12345678910111213141516171819202122232425262728293031323334&lt;script&gt; var header = Vue.component('header', { template: '&lt;div class=&quot;header&quot;&gt;header&lt;/div&gt;' }); var sidebar = Vue.component('sidebar', { template: '&lt;div class=&quot;sidebar&quot;&gt;sidebar&lt;/div&gt;' }); var mainbox = Vue.component('mainbox', { template: '&lt;div class=&quot;mainbox&quot;&gt;mainbox&lt;/div&gt;' }); // 创建路由对象 var router = new VueRouter({ routes: [ { path: '/', components: { default: header, a: sidebar, b: mainbox } } ] }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: {}, router }); &lt;/script&gt; CSS 样式：12345678910111213141516171819&lt;style&gt; .header { border: 1px solid red; } .content{ display: flex; } .sidebar { flex: 2; border: 1px solid green; height: 500px; } .mainbox{ flex: 8; border: 1px solid blue; height: 500px; }&lt;/style&gt; watch属性的使用考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？） 监听data中属性的改变：1234567891011121314151617181920212223242526&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; = &lt;span&gt;{{fullName}}&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { firstName: 'jack', lastName: 'chen', fullName: 'jack - chen' }, methods: {}, watch: { 'firstName': function (newVal, oldVal) { // 第一个参数是新数据，第二个参数是旧数据 this.fullName = newVal + ' - ' + this.lastName; }, 'lastName': function (newVal, oldVal) { this.fullName = this.firstName + ' - ' + newVal; } } }); &lt;/script&gt; 监听路由对象的改变：1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = Vue.extend({ template: '&lt;h1&gt;登录组件&lt;/h1&gt;' }); var register = Vue.extend({ template: '&lt;h1&gt;注册组件&lt;/h1&gt;' }); var router = new VueRouter({ routes: [ { path: &quot;/login&quot;, component: login }, { path: &quot;/register&quot;, component: register } ] }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: {}, router: router, watch: { '$route': function (newVal, oldVal) { if (newVal.path === '/login') { console.log('这是登录组件'); } } } }); &lt;/script&gt; computed计算属性的使用 默认只有getter的计算属性：12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; = &lt;span&gt;{{fullName}}&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { firstName: 'jack', lastName: 'chen' }, methods: {}, computed: { // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值 fullName() { return this.firstName + ' - ' + this.lastName; } } }); &lt;/script&gt; 定义有getter和setter的计算属性：123456789101112131415161718192021222324252627282930313233343536&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt; &lt;input type=&quot;button&quot; value=&quot;修改fullName&quot; @click=&quot;changeName&quot;&gt; &lt;span&gt;{{fullName}}&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { firstName: 'jack', lastName: 'chen' }, methods: { changeName() { this.fullName = 'TOM - chen2'; } }, computed: { fullName: { get: function () { return this.firstName + ' - ' + this.lastName; }, set: function (newVal) { var parts = newVal.split(' - '); this.firstName = parts[0]; this.lastName = parts[1]; } } } }); &lt;/script&gt; watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； nrm的安装使用作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样； 运行npm i nrm -g全局安装nrm包； 使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 使用nrm use npm或nrm use taobao切换不同的镜像源地址； 相关文件 URL中的hash（井号） Day5 # Vue.js - Day5 - Webpack 在网页中会引用哪些常见的静态资源？ JS .js .jsx .coffee .ts（TypeScript 类 C# 语言） CSS .css .less .sass .scss Images .jpg .png .gif .bmp .svg 字体文件（Fonts） .svg .ttf .eot .woff .woff2 模板文件 .ejs .jade .vue【这是在webpack中定义组件的方式，推荐这么用】 网页中引入的静态资源多了以后有什么问题？？？ 网页加载速度慢， 因为 我们要发起很多的二次请求； 要处理错综复杂的依赖关系 如何解决上述两个问题 合并、压缩、精灵图、图片的Base64编码 可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系； 什么是webpack?webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具； 如何完美实现上述的2种解决方案 使用Gulp， 是基于 task 任务的； 使用Webpack， 是基于整个项目进行构建的； 借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。 根据官网的图片介绍webpack打包的过程 webpack官网 webpack安装的两种方式 运行npm i webpack -g全局安装webpack，这样就能在全局使用webpack的命令 在项目根目录中运行npm i webpack --save-dev安装到项目依赖中 初步使用webpack打包构建列表隔行变色案例 运行npm init初始化项目，使用npm管理项目中的依赖包 创建项目基本的目录结构 使用cnpm i jquery --save安装jquery类库 创建main.js并书写各行变色的代码逻辑：1234567// 导入jquery类库 import $ from 'jquery' // 设置偶数行背景色，索引从0开始，0是偶数 $('#list li:even').css('backgroundColor','lightblue'); // 设置奇数行背景色 $('#list li:odd').css('backgroundColor','pink'); 直接在页面上引用main.js会报错，因为浏览器不认识import这种高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法； 运行webpack 入口文件路径 输出文件路径对main.js进行处理：1webpack src/js/main.js dist/bundle.js 使用webpack的配置文件简化打包时候的命令 在项目根目录中创建webpack.config.js 由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在webpack.config.js中配置这两个路径：1234567891011// 导入处理路径的模块var path = require('path');// 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理module.exports = { entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件 output: { // 配置输出选项 path: path.resolve(__dirname, 'dist'), // 配置输出的路径 filename: 'bundle.js' // 配置输出的文件名 }} 实现webpack的实时打包构建 由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用webpack-dev-server来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。 运行cnpm i webpack-dev-server --save-dev安装到开发依赖 安装完成之后，在命令行直接运行webpack-dev-server来进行打包，发现报错，此时需要借助于package.json文件中的指令，来进行运行webpack-dev-server命令，在scripts节点下新增&quot;dev&quot;: &quot;webpack-dev-server&quot;指令，发现可以进行实时打包，但是dist目录下并没有生成bundle.js文件，这是因为webpack-dev-server将打包好的文件放在了内存中 把bundle.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快 这个时候访问webpack-dev-server启动的http://localhost:8080/网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，此时引用不到bundle.js文件，需要修改index.html中script的src属性为:&lt;script src=&quot;../bundle.js&quot;&gt;&lt;/script&gt; 为了能在访问http://localhost:8080/的时候直接访问到index首页，可以使用--contentBase src指令来修改dev指令，指定启动的根目录：1&quot;dev&quot;: &quot;webpack-dev-server --contentBase src&quot; 同时修改index页面中script的src属性为&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 使用html-webpack-plugin插件配置启动页面由于使用--contentBase指令的过程比较繁琐，需要指定启动的目录，同时还需要修改index.html中script标签的src属性，所以推荐大家使用html-webpack-plugin插件配置启动页面. 运行cnpm i html-webpack-plugin --save-dev安装到开发依赖 修改webpack.config.js配置文件如下：123456789101112131415161718// 导入处理路径的模块var path = require('path');// 导入自动生成HTMl文件的插件var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = { entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件 output: { // 配置输出选项 path: path.resolve(__dirname, 'dist'), // 配置输出的路径 filename: 'bundle.js' // 配置输出的文件名 }, plugins:[ // 添加plugins节点配置插件 new htmlWebpackPlugin({ template:path.resolve(__dirname, 'src/index.html'),//模板路径 filename:'index.html'//自动生成的HTML文件的名称 }) ]} 修改package.json中script节点中的dev指令如下：1&quot;dev&quot;: &quot;webpack-dev-server&quot; 将index.html中script标签注释掉，因为html-webpack-plugin插件会自动把bundle.js注入到index.html页面中！ 实现自动打开浏览器、热更新和配置浏览器的默认端口号注意：热更新在JS中表现的不明显，可以从一会儿要讲到的CSS身上进行介绍说明！ 方式1： 修改package.json的script节点如下，其中--open表示自动打开浏览器，--port 4321表示打开的端口号为4321，--hot表示启用浏览器热更新：1&quot;dev&quot;: &quot;webpack-dev-server --hot --port 4321 --open&quot; 方式2： 修改webpack.config.js文件，新增devServer节点如下：12345devServer:{ hot:true, open:true, port:4321 } 在头部引入webpack模块：1var webpack = require('webpack'); 在plugins节点下新增：1new webpack.HotModuleReplacementPlugin() 使用webpack打包css文件 运行cnpm i style-loader css-loader --save-dev 修改webpack.config.js这个配置文件：12345module: { // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 { test: /\\.css$/, use: ['style-loader', 'css-loader'] }//处理css文件的规则 ] } 注意：use表示使用哪些模块来处理test所匹配到的文件；use中相关loader模块的调用顺序是从后向前调用的； 使用webpack打包less文件 运行cnpm i less-loader less -D 修改webpack.config.js这个配置文件：1{ test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] }, 使用webpack打包sass文件 运行cnpm i sass-loader node-sass --save-dev 在webpack.config.js中添加处理sass文件的loader模块：1{ test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] } 使用webpack处理css中的路径 运行cnpm i url-loader file-loader --save-dev 在webpack.config.js中添加处理url路径的loader模块：1{ test: /\\.(png|jpg|gif)$/, use: 'url-loader' } 可以通过limit指定进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码：1{ test: /\\.(png|jpg|gif)$/, use: 'url-loader?limit=43960' }, 使用babel处理高级JS语法 运行cnpm i babel-core babel-loader babel-plugin-transform-runtime --save-dev安装babel的相关loader包 运行cnpm i babel-preset-es2015 babel-preset-stage-0 --save-dev安装babel转换的语法 在webpack.config.js中添加相关loader模块，其中需要注意的是，一定要把node_modules文件夹添加到排除项：1{ test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/ } 在项目根目录中添加.babelrc文件，并修改这个配置文件如下：1234{ &quot;presets&quot;:[&quot;es2015&quot;, &quot;stage-0&quot;], &quot;plugins&quot;:[&quot;transform-runtime&quot;]} 注意：语法插件babel-preset-es2015可以更新为babel-preset-env，它包含了所有的ES相关的语法； 相关文章babel-preset-env：你需要的唯一Babel插件Runtime transform 运行时编译es6","link":"/2020/03/13/vue-heima-1/"}],"tags":[{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"Node","slug":"Node","link":"/tags/Node/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"}],"categories":[{"name":"Windows","slug":"Windows","link":"/categories/Windows/"},{"name":"Node","slug":"Node","link":"/categories/Node/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"}]}