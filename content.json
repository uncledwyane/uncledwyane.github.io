{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"archives","text":"","link":"/archives/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"schedule","text":"","link":"/schedule/index.html"}],"posts":[{"title":"webpack中跨域问题(已解决)","text":"最近几天学完了vue的基本课程，想跟着教程做个实战，由于教程不是最新的，里面涉及到的接口就失效了，于是网上找了个接口，使用axios请求数据发现控制台居然报了上面这个错，还是小白的我一脸懵b，马上百度，发现一个专有名词： 跨域，跨域的解释这里就不啰嗦了，百度一大堆。为了解决这个问题，翻了很多篇教程，无果......... 一直解决不了这个问题，作为小白真想放弃，但第二天还是决定认真看一看其他教程，最终找到了webpack中解决跨域问题的办法，就是在`webpack.config.js`中加入以下语句： 12345678910module.exports = { devServer: { proxy: { '/api': { target: 'http: www.exsample.cn', changeOrigin: true } } }} 重点就是这个`changeOrigin: true`， 在上面的代码中,`/api`就是在请求中，遇到这个开头的就马上代理为本地服务器，比如要请求的网络地址是`http://jiekou.cn/api/data.json`，那么经过webpack这段配置文件处理过后请求的地址就转变为本地服务器地址`http://localhost:8080/api/data.json`，这样本地服务器去请求接口数据的头部都是`localhost:8080`了","link":"/2020/04/07/cross-origin/"},{"title":"关于CSS3的一些属性","text":"1.auto,vw,vh 1234width:auto; //子元素会撑开至父元素的宽度，但会减去自身Margin和Padding的大小，不会溢出。width：100%; //子元素会撑开父元素至的宽度，但如果自身还有Margin或者Padding，则宽度是父元素的宽度加上Margin和Padding的宽度，会溢出。width:50vw; //这里的vw表示视窗宽度的百分比，1vw就是50%的宽度。height:50vh; //这里的vh视窗高度的百分比，50vh就是视窗高度的50%。 2.css3的新属性：vw、vh、vmin、vmax 1234vw：视窗宽度的百分比（1vw 代表视窗的宽度为 1%）vh：视窗高度的百分比vmin：当前 vw 和 vh 中较小的一个值vmax：当前 vw 和 vh 中较大的一个值 3.vw、vh 与 % 百分比的区别 % 是相对于父元素的大小设定的比率，vw、vh 是视窗大小决定的。 vw、vh 优势在于能够直接获取高度，而用 % 在没有设置 body 高度的情况下，是无法正确获得可视区域的高度的，所以这是挺不错的优势。","link":"/2019/11/17/CSSvalue/"},{"title":"使用GitHub仓库来保存自己的代码","text":"绑定GitHub获取电脑的密钥 在Gitbash中输入Add-AppxPackage -register AppxManifest.xml并回车，回车，再回车 打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开复制里面的内容，这就是密钥 点击Github自己的头像里面的setting，找到SSH and GPG keys，点击右侧New SSH key随意填一个名称，在下面填入id_rsa.pub里面的内容，保存，这样就把电脑和Github绑定了 本地上传到GitHub GitHub里面新建一个代码仓库，名称随意 进入仓库,复生成的https链接： 在本地新建一个文件夹，使用GitBash进入这个文件夹，执行命令：1git init 命令执行完毕后这个文件夹下面就会生成一个.git的文件夹，这样就初始化完毕了 在文件夹下新建一个helloGit.txt文件做测试 执行以下命令1234git add helloGit.txt // 选择文件git commit -m &quot;提交测试&quot; // 本次提交的描述信息git remote add origin 刚刚复制的链接 // 绑定刚刚创建的远程Git仓库git push -u origin master // 提交 这样就完成了将自己电脑和GitHub远程仓库的绑定","link":"/2020/04/07/git-res-tutorial/"},{"title":"如何有效的卸载Windows的软件","text":"在电脑中，卸载软件不如手机那么方便，方法多种多样，但往往都卸载不干净，残留注册表等不好删除。所以需要借助第三方工具来帮助我们轻松并且完完全全的卸载掉想要卸载的软件，这篇文章要推荐的就是IObit Uninstaller这款软件，它UI漂亮，操作便捷，卸载彻底！试一试吧！","link":"/2020/03/28/howtouninstall/"},{"title":"JAVA-抽象","text":"JAVA中的抽象，作业实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//定义了一个抽象基类（父类）public abstract class Shape { protected String shapeName; public abstract double getArea(); //抽象方法 public abstract double getLength(); //抽象方法 Shape(String shapeName) { this.shapeName = shapeName; System.out.println(\"形状是：\"+shapeName); } public static void main(String args[]) { Shape rectangle,circle; rectangle = new Rectangle(\"矩形\", 3.0, 4.0); rectangle.getArea(); rectangle.getLength(); circle = new Circle(\"圆\", 5.0); circle.getArea(); circle.getLength(); } }//继承自Shape类，必须实现父类的抽象方法class Rectangle extends Shape{ Double area,length,width,height; Rectangle(String shapeName,double width,double height) { super(shapeName); this.width = width; this.height = height; } //实现父类中的getArea方法 public double getArea() { area = width * height; System.out.println(\"面积是：\" + area); return area; } //实现父类中的getLength方法 public double getLength() { length = 2 * (width + height); System.out.println(\"周长是：\" + length); return length; } }//继承自Shape类，必须实现父类的抽象方法class Circle extends Shape{ Double area,length,radius; final double PI = 3.14; Circle(String shapeName,double radius) { super(shapeName); this.radius = radius; } //实现父类中的getArea方法 public double getArea() { area = PI * (radius * radius); System.out.println(\"面积是：\" + area); return area; } //实现父类中的getLength方法 public double getLength() { length = (2 * radius) * PI; System.out.println(\"周长是：\" + length); return length; } }","link":"/2019/10/26/java-AbstractDemo/"},{"title":"(Java)猜一个随机数字","text":"GuessRandomNuber.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class GuessRandomNumber extends JFrame { private ButtonPanel panel; private JTextField input; private JLabel output; private Random random; private int randomInt; //设置一个随机数 public void createRandomInt() { random = new Random(); randomInt = random.nextInt(1000) + 1; System.out.println(\"随机数是：\" + randomInt); } /*初始化方法*/ public void init() { //设置窗体属性 setSize(600,337); setTitle(\"窗体\"); //初始化组件 input = new JTextField(); output = new JLabel(\"请猜个数字\"); panel = new ButtonPanel(); //获取面板 Container con = this.getContentPane(); //面板设置布局 con.setLayout(new BorderLayout()); //panel.setLayout(new GridLayout(1,3)); //将组件添加到面板 con.add(input,BorderLayout.NORTH); con.add(output,BorderLayout.CENTER); con.add(panel,BorderLayout.SOUTH); //设置组件属性 output.setFont(new Font(\"XHei\",Font.BOLD,20)); output.setForeground(Color.RED); setVisible(true); //设置默认关闭动作 setDefaultCloseOperation(EXIT_ON_CLOSE); //生成一个随机数 createRandomInt(); panel.getGuess().addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { // TODO Auto-generated method stub output.setText(\"Guess...\"); String value = input.getText(); int guessNumer = -1; try { guessNumer = Integer.parseInt(value); } catch (NumberFormatException e1) { // TODO Auto-generated catch block e1.printStackTrace(); output.setText(\"您输入的不是数字，请重新输入\"); return; } if(guessNumer &lt; 0 || guessNumer &gt; 1000) { output.setText(\"猜的数字要在1~1000，请重新输入\"); return; } if(guessNumer &gt; randomInt) { output.setText(\"猜大了，往小了猜\"); input.setText(\"\"); } else if( guessNumer &lt; randomInt) { output.setText(\"猜小了，往大了猜\"); input.setText(\"\"); } else { output.setText(\"恭喜你，猜对了\"); input.setText(\"\"); } } }); panel.getReset().addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { // TODO Auto-generated method stub createRandomInt(); System.out.println(\"随机数是：\" + randomInt); output.setText(\"请猜一个数字\"); } }); panel.getExit().addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { // TODO Auto-generated method stub System.exit(0); } }); } /*构造方法*/ public GuessRandomNumber() { init(); } public static void main(String[] args) { new GuessRandomNumber(); }} ButtonPanel.java 123456789101112131415161718192021222324252627282930313233343536public class ButtonPanel extends JPanel{ private JButton guess,reset,exit; public JButton getGuess() { return guess; } public void setGuess(JButton guess) { this.guess = guess; } public JButton getReset() { return reset; } public void setReset(JButton reset) { this.reset = reset; } public JButton getExit() { return exit; } public void setExit(JButton exit) { this.exit = exit; } public void init() { guess = new JButton(\"猜\"); reset = new JButton(\"重置\"); exit = new JButton(\"退出\"); setLayout(new GridLayout(1,3)); add(guess); add(reset); add(exit); } public ButtonPanel() { init(); }}","link":"/2020/01/11/java-GUI-GuessRandomNumber/"},{"title":"Java作业","text":"BMI计算器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.text.DecimalFormat;import java.util.Scanner;import org.omg.CORBA.PRIVATE_MEMBER;class GetBMI{ double weight,height,final_BMI; boolean right = true; //计算BMI的值 double GetBMI(){ final_BMI = weight/(height*height); return final_BMI; } //获取身高体重数据，并对输入的数据进行可行性验证 void getData() { boolean a = true; Scanner input = new Scanner(System.in); while(a) { System.out.println(\"请输入你的体重:\"); if(input.hasNextDouble()) { weight = input.nextDouble(); System.out.println(\"请输入你的身高:\"); height = input.nextDouble(); break; }else { System.out.println(\"数据输入错误，请重新来！\"); continue; } } } //获取BMI所在的范围，打印出提醒语句 void compare() { GetBMI(); if (final_BMI &gt;= 40) { System.out.println(\"You can go die!!!!\"); }else if(final_BMI &gt;= 35 &amp;&amp; final_BMI &lt; 40) { System.out.println(\"你严重肥胖！\"); }else if (final_BMI &gt;= 30 &amp;&amp; final_BMI &lt; 35) { System.out.println(\"你属于肥胖！\"); }else if (final_BMI &gt;= 25 &amp;&amp; final_BMI &lt; 30) { System.out.println(\"你属于偏胖！\"); }else if (final_BMI &gt;= 18 &amp;&amp; final_BMI &lt; 25 ) { System.out.println(\"你的BMI正常！\"); }else{ System.out.println(\"你太瘦了！\"); } } //获得计算结果并输出 void show() { DecimalFormat dFormat = new DecimalFormat(\"0.00\"); this.GetBMI(); System.out.println(\"Your BMI is :\"+dFormat.format(final_BMI)); compare(); } }public class BMICauculator { public static void main(String[] args) { // TODO Auto-generated method stub GetBMI bmi = new GetBMI(); bmi.getData(); bmi.show(); }}","link":"/2019/10/15/java-homework/"},{"title":"Cmd Markdown","text":"这是一篇关于个人博客最普遍使用的编辑语言MarkDown的介绍以及简单的理解 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。","link":"/2018/06/23/markdown%20eidtor/"},{"title":"记录在使用webpack做的项目过程中遇到的问题及解决办法和总结","text":"问题一： 背景：做一个新闻页面，每一条新闻点进去进入新闻详情的时候，之前是点进去之后再次请求服务器数据，这样就请求了两次，对访问速度也有影响，也浪费资源。 问题：怎么才能直接把每条新闻获取的数据在点击之后直接传到新闻详情页 解决： 试过使用中央事件总线bus来在两个组件之间传递数据，但是测试的时候，只能在控制台看见数据，不能传给接收组件自己的变量。或者说是我的使用方式不正确。效果不佳，舍弃。 搜索一番发现，可以使用$router来传值，很方便. 点击阅读更多查看使用方法 下面是使用方法:要发送数据的组件： 123456789101112131415data(){ return: { data: 'Hello' } }, methods: { sendData(){ this.$router.push({ path: '/home', query: { data: this.data } }) } } 要接收数据的组件： 12345678910data(){ return: { mydata: '' } }methods: { getData(){ this.mydata = this.$route.query.data } } 问题二: 如何在手机上调试项目 背景：局域网ip为192.168.101.8 保证电脑和手机在同一局域网下（连接同一wifi） 在package.json中的启动参数中添加--host 192.168.101.8 手机访问这个ip地址+端口号+项目首地址 例如：原本项目地址为：localhost:8080/#/home 配置后：192.168.101.8:8080/#/home 手机访问这个地址即可","link":"/2020/04/17/my-project-note/"},{"title":"我的第一个项目下线啦","text":"历时一个多月学习了Vue之后结合教程做的第一个小项目，我觉得可以归类为移动端的小程序。 通过这个小小的项目，一个在以后看起来很渣渣的小项目，让现在的我对Vue的理解更加深刻，还学习了webpack、axios、Promise、接口、vue-cli等很多以及其他UI组件库的使用。 这个项目还有很多不足，存在的问题有： 重复请求api数据，点击过的页面和获取过的数据重新进入会丢失并重新发起请求 新闻列表点进一条新闻之后再回到新闻列表不能还原点击之前的分类和界面 新闻列表传参是显示传参，后期会优化为隐式传参 项目演示 项目使用的相关： UI Mint-UI Vant-UI Muse-UI MUI 技术栈 Webpack Vue.js Axios 接口： 聚合数据 进制数据 一言","link":"/2020/04/25/myfirstpractice/"},{"title":"拉勾网职位爬取","text":"一个爬取拉勾网职位信息简单程序，涉及到异步加载，使用json分析数据并保存到MongoDB数据库 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import requestsimport jsonimport timeimport pymongoclient = pymongo.MongoClient('127.0.0.1', 27017)mydb = client['jobs']lagou = mydb['lagou']headers = { 'Accept': 'application/json, text/javascript, */*; q=0.01', 'Accept-Encoding': 'gzip, deflate, br', 'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8', 'Connection': 'keep-alive', 'Content-Length': '37', 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8', 'Cookie': '_ga=GA1.2.1069426576.1578732618;' ' index_location_city=%E5%85%A8%E5%9B%BD;' ' user_trace_token=20200111165020-251b21ca-0efa-4e3a-b959-93855c309d4d;' ' lagou_utm_source=B;' ' JSESSIONID=ABAAAECABBJAAGI5F960B86A5C58E135C92D5813AEC82AC;' ' WEBTJ-ID=20200202115956-170040e12e86-02f47fddf1f558-b383f66-2073600-170040e12e96f0;' ' X_MIDDLE_TOKEN=dbdf524e8683f15975fa5fde4d8f2f39;' ' X_HTTP_TOKEN=669a21470347f2436986360851ac25caf63ec40c85;' ' _gat=1;' ' SEARCH_ID=f04d4617085a4104bf037670fd36f76c', 'Host': 'www.lagou.com', 'Origin': 'https://www.lagou.com', 'Referer': 'https://www.lagou.com/jobs/list_java/', 'Sec-Fetch-Mode': 'cors', 'Sec-Fetch-Site': 'same-origin', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)' \\ ' Chrome/79.0.3945.130 Safari/537.36', 'X-Anit-Forge-Code': '0', 'X-Anit-Forge-Token': 'None', 'X-Requested-With': 'XMLHttpRequest'}def get_page(url, params): html = requests.post(url, data=params, headers=headers) print(html.text) json_data = json.loads(html.text) total_count = json_data['content']['positionResult']['totalCount'] page_number = int(total_count/15) if int(total_count/15) &lt; 30 else 30 get_info(url, page_number)def get_info(url, page): for pn in range(1, page+1): params = { 'first': 'true', 'pn': str(pn), 'kd': '游戏' } try: html = requests.post(url, data=params, headers=headers) json_data = json.loads(html.text) results = json_data['content']['positionResult']['result'] for result in results: infos = { 'businessZones': result['businessZones'], 'city': result['city'], 'district': result['district'], 'companyFullName': result['companyFullName'], 'companyShortName': result['companyShortName'], 'companySize': result['companySize'], 'industryField': result['industryField'], 'financeStage': result['financeStage'], 'firstType': result['firstType'], 'secondType': result['secondType'], 'thirdType': result['thirdType'], 'companyLabelList': result['companyLabelList'], 'salary': result['salary'], 'workYear': result['workYear'], 'education': result['education'], 'positionName': result['positionName'], } lagou.insert_one(infos) time.sleep(2) except KeyError: print(\"关键词错误\") passif __name__ == '__main__': url = 'https://www.lagou.com/jobs/positionAjax.json' params = { 'first': 'true', 'pn': '1', 'kd': 'java' } get_page(url, params) time.sleep(0.5)","link":"/2020/02/10/python-lagou/"},{"title":"第一个爬虫项目","text":"第一个爬虫项目：爬取前程无忧重庆地区工作 LoginUI.py 1234567891011121314151617181920212223242526272829303132333435363738from tkinter import *import tkinter as tkimport tkinter.messageboxfrom SearchItemUI import *win = Tk()win.geometry('368x600')win.title('Login UI')bg_photo = tk.PhotoImage(file='img/login_bg.png')bg_label = tk.Label( win, image=bg_photo, compound=tk.CENTER).pack()labelimg = PhotoImage(file='img/smile.png')img_label = Label(win, image=labelimg).place(x=120, y=60)text_username = Label(win, bg='#68ABFF', fg='#fff', text='账号:', font=('Xhei', '16')).place(x=60, y=240)text_password = Label(win, bg='#94C3FF', fg='#fff', text='密码:', font=('Xhei', '16')).place(x=60, y=280)username = StringVar()password = StringVar()input_username = Entry(win, textvariable=username, font=('Xhei', '16'), width=14).place(x=120, y=240)inout_password = Entry(win, textvariable=password, font=('Xhei', '16'), show='*', width=14).place(x=120, y=280)def check_login(): username_get = username.get() password_get = password.get() if username_get == 'user' and password_get == '123456': win.destroy() start_search() elif username_get == '' or password_get == '': tk.messagebox.showwarning(title='警告', message='请输入用户名或者密码!') else: tk.messagebox.showwarning(title='警告', message='用户名或者密码错误!')btn_login = Button(win, command=check_login, text='登录', font=('Xhei', '16'), bg=\"#68ABFF\", fg=\"#FFF\").place(x=140, y=340)win.mainloop() SearchItemUI.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128from tkinter import *import requestsimport webbrowserimport reimport tkinter.ttk as ttkfrom bs4 import BeautifulSoupdef start_search(): win = Tk() win.title(\"51Job招聘\") win.geometry('690x760') job_categorie = StringVar() keyword = StringVar() page_num = IntVar() v = IntVar() com_type_value = StringVar() top = Toplevel(win) top.title(\"详细信息\") top.geometry('930x724') title = ['l1', 'l2', 'l3', 'l4'] tree = ttk.Treeview(top, column=title, show='headings', height=20, selectmode='browse') tree.column('l1', anchor='center', width=300) tree.column('l2', anchor='center', width=300) tree.column('l3', anchor='center', width=145) tree.column('l4', anchor='center', width=145) tree.heading('l1', text='职位') tree.heading('l2', text='公司名称') tree.heading('l3', text='工作地点') tree.heading('l4', text='薪资待遇') tree.place(x=0, y=0, width=903, height=725) vbar = ttk.Scrollbar(top, orient=\"vertical\", command=tree.yview) tree.configure(yscrollcommand=vbar.set) vbar.place(x=904, y=5, height=720) def search_job(): input_keyword = keyword.get() input_page_num = page_num.get() select_com_type_value = com_type_value.get() the_url = \"https://search.51job.com/list/060000,000000,0000,00,9,99,%s,2,%d.html\" % (input_keyword, input_page_num) headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) ' 'Chrome/78.0.3904.108 Safari/537.36'} response = requests.get(the_url, headers=headers) response.encoding = 'gbk' html = response.text soup = BeautifulSoup(html, features='lxml') all_div_e1 = soup.select('div[class=\"el\"]') span_t1 = soup.find_all('span', {'class': 't1'}) all_div_jobpositions = soup.find_all('p', {'class': 't1'}) all_companys = soup.find_all('span', {'class': 't2'}) all_address = soup.find_all('span', {'class': 't3'}) all_salary = soup.find_all('span', {'class': 't4'}) job_list = [] companys_list = [] address_list = [] salary_list = [] for item in all_div_jobpositions: all_titles = item.find_all('a') job_list.append(all_titles[0].get_text().strip('\\r').strip('\\n').strip(' ').strip('.')) for get_item in all_companys: get_a = get_item.find_all('a') for i in get_a: com_name = i.get_text().strip('.') companys_list.append(com_name) for add in all_address: the_list = [] add_value = add.get_text() the_list.append(add_value) address_list = address_list + the_list for salary in all_salary: the_list = [] salary_value = salary.get_text() if salary_value == \"\": salary_value = \"未知或面谈\" the_list.append(salary_value) salary_list = salary_list + the_list address_list.pop(0) salary_list.pop(0) zipped = zip(job_list, companys_list, address_list, salary_list) for zip_item in zipped: tree.insert(\"\", 1, value=zip_item) def clear_data(): items = tree.get_children() for each_item in items: tree.delete(each_item) wrap_framl = LabelFrame(win, text=\"搜索\", font=('Xhei', '14'), width=650, height=80) \\ .place(x=20, y=30) label_notice = Label(wrap_framl, text='职位关键词:', font=('Xhei', '13')) \\ .place(x=35, y=60) keyword_entry = Entry(wrap_framl, textvariable=keyword, font=('Xhei', '13')) \\ .place(x=150, y=60) label_page_num = Label(wrap_framl, text=\"页数:\", font=('Xhei', '13')) \\ .place(x=370, y=60) page_num_chosen = ttk.Combobox(wrap_framl, width=10, textvariable=page_num) page_num_chosen['values'] = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10) page_num_chosen.current(0) page_num_chosen.place(x=425, y=60) search_btn = Button(wrap_framl, text='搜索', font=('Xhei', '13'), bg='red', fg='white', command=search_job) \\ .place(x=540, y=55) clear_data_btn = Button(wrap_framl, text='清除', font=('Xhei', '13'), bg='red', fg='white', command=clear_data) \\ .place(x=600, y=55) other_keyword_label = Label(win, text=\"其他关键词\", font=('Xhei', '14'), bg='red', fg='white')\\ .place(x=290, y=130) wrap_fram2 = LabelFrame(win, text=\"公司性质\", width=200, height=570, font=('Xhei', '14')) \\ .place(x=20, y=170) company_type = [('所有', '99'), ('国企', '04'), ('外资(欧美)', '01'), ('外资(非欧美)', '02'), ('上市公司', '10'), ('合资', '03'), ('民营', '05'), ('外企代表处', '06'), ('政府机关', '07'), ('事业单位', '08')] i = 0 for com_type, com_type_num in company_type: Radiobutton(wrap_fram2, text=com_type, value=com_type_num, variable=v, font=('XHei', '13'))\\ .place(x=30, y=220+i) i += 50 wrap_fram3 = LabelFrame(win, text=\"工资范围\", width=200, height=570, font=('Xhei', '14')) \\ .place(x=245, y=170) wrap_fram4 = LabelFrame(win, text=\"学历要求\", width=200, height=570, font=('Xhei', '14')) \\ .place(x=470, y=170) win.mainloop()start_search()","link":"/2019/11/28/python-scrapy/"},{"title":"Python作业","text":"Python作业，熟悉Python语法基础 题目背景介绍：你准备去海南旅游，现在要订购机票。机票的价格受旺季、淡季影响，而且头等舱和经济舱的价格也不同。假设机票原价是5000元，4~10月为旺季，旺季头等舱打9折，经济舱6折；其他月份为淡季，淡季头等舱5折，经济舱4折，编写程序，根据出行的月份和选择的舱位输出实际机票的价格。 1234567891011121314151617181920final_price = 0price = 5000print('请输入你想出行的月份(1~12)：')month = eval(input())print('请输入你想购买的舱位，头等舱输入1，二等舱输入2')level = eval(input())if month &gt;= 4 and month &lt;= 10: if level == 1: final_price = price * 0.9 print('您的机票价格为：' + str(final_price)) elif level == 2: final_price = price * 0.6 print('您的机票价格为：' + str(final_price))else: if level == 1: final_price = price * 0.5 print('您的机票价格为：' + str(final_price)) elif level == 2: final_price = price * 0.4 print('您的机票价格为：' + str(final_price)) 题目：输入一批数字，输出其中的最大值和最小值，输入数字0结束. 123456789101112131415a = 0list = []while a == 0: print('请输入一个数:') number = eval(input()) list.append(number) if number == 0: a != 0 break else: continuelist.sort(reverse=True)print('最大值为:' + str(list[0]))list.sort()print('最小值为：' + str(list[1])) 题目：创建一个列表，将员工月薪数据保存到其中，并对列表进行如下操作：1.添加一名月薪6000的员工至列表末尾2.插入一名月薪7500的员工到列表中索引为2的位置3.移除列表中最后一个数据，并显示移除的值4.将列表中的第二个数据的值增加1005.删除列表中第5个数据6.按顺序遍历输出员工的月薪7.将所有月薪小于5000的员工月薪，修改为5000，并输出其索引值 1234567891011121314151617181920month_salary = [{'id':'a1','name':'王保华','salary':10000}, {'id':'a2','name':'李维新','salary':5200}, {'id':'a3','name':'张强','salary':4700}, {'id':'a4','name':'张明','salary':3860}, {'id':'a5','name':'陈鑫','salary':1200}, {'id':'a6','name':'李牧','salary':8500}]month_salary.append({'salary':6000})month_salary.insert(2,{'salary':7500})month_salary[1]['salary'] += 100month_salary.pop(4)for i in range (len(month_salary)): if month_salary[i]['salary'] &lt; 5000: month_salary[i]['salary'] = 5000 index = i print('月薪低于5000的索引为：' + str(index)) else: month_salary[i]['salary'] = month_salary[i]['salary']for i in range (len(month_salary)): print(month_salary[i]) 创建一个字典，将员工工号、姓名、月薪数据保存到字典中，并按要求做如下操作:1.打印所有员工信息2.从字典中获取员工工号为“a4”的员工信息，并打印3.判断是否有工号为“a9”的员工，如果存在，输出该员工信息；否则输出“员工不存在”4.遍历字典中所有员工信息，并输出5.添加一名员工数据：工号a7，姓名李梅，月薪90006.将工号为a4的员工的月薪修改为49007.删除列表中工号为a4的员工数据 1234567891011121314151617181920212223month_salary = {'a1':['王保华',10000], 'a2':['李维新',10000], 'a3':['张强',10000], 'a4':['张明',10000], 'a5':['陈鑫',10000], 'a6':['李牧',10000]}i = 'a9'print(month_salary)print(month_salary['a4'])if i in month_salary: employee = month_salary[i] print('工号为%s的员工信息：'%i) print(employee)else: print('员工不存在')for number in month_salary: print(month_salary['%s'%number])month_salary['a7'] = ['李梅',9000]month_salary['a4'][1] = 4900print(month_salary['a4'][1])print(month_salary)del month_salary['a4']print(month_salary) 统计诗经《桃夭》中出现的汉字和标点的次数。1.使用字符串保存《桃夭》2.遍历诗歌中所有的汉字和标点3.遍历过程中统计用到了哪些汉字和标点4.统计汉字和标点个数使用字典结构5.判断字符是否在字典中，如果在，则将该键对应的值加1，如果不在则新创建该键，并赋值16.使用for循环遍历输出汉字、标点的使用个数 123456789poem = \"\"\"桃之夭夭，灼灼其华。之子于归，宜其室家。桃之夭夭，有蕡其实。之子于归，宜其家室。桃之夭夭，其叶蓁蓁。之子于归，宜其家人。\"\"\"character_counts = {}for character in poem: if character in character_counts: character_counts[character] += 1 else: character_counts[character] = 1for key in character_counts: print(\"%s出现了 %d次\"%(key,character_counts[key])) 定义函数接收年份和月份，返回对应的月份有多少天：闰年二月为29天，否则为28天（闰年就是二月有29天的年份，能被4整除但不能被100整除的是闰年，能被400整除的也是闰年）。4,6,9,11月为30天,其余月为31天 123456789101112131415161718def getYear(): print('请输入一个年份：') year = eval(input()) print('请输入月份：') month = eval(input()) if(year % 4 == 0 and year % 100 != 0 or year % 400 == 0): if month == 2: print('%d年%d月有29天'%(year,month)) else: print('%d年%d月有29天' % (year, month)) else: if month == 4 or month == 6 or month == 9 or month == 11: print('%d年%d月有30天'%(year,month)) elif month == 2: print('%d年%d月有28天' % (year, month)) else: print('%d年%d月有31天' % (year, month))getYear()","link":"/2019/10/10/Python/"},{"title":"配置了跨域，但是请求还是显示404的解决办法","text":"原来使用npm run dev重启以下项目就行了，因为这个问题头疼了很久，以为跨域配置错误","link":"/2020/04/13/solution-404/"},{"title":"Windows10&#x2F;Office系列软件激活教程","text":"这个教程仅在Win10和Office16以后的版本做过测试并通过，其它Windows系统和其它Office软件版本未作测试，可以自行激活。 点击下方“阅读更多”进入教程 激活前提 退出Windows自带安全软件或者360等安全软件，此激活程序请放心使用 下载KMS程序压缩包，点击下方链接下载KMS 下载完成后解压，得到一个名为KMS文件夹 进入文件夹，点击KMSpico_setup.exe进行安装 下载链接：https://pan.baidu.com/s/1hsnChXWHXtkC2GEZzqgH4w 提取码: yavm 开始 执行上一步之后，不会显示软件界面，后台自动激活，听到Program Complete表示激活完成 激活完成","link":"/2020/02/22/tips-win-active/"},{"title":"Vue 组件 | 子组件索引","text":"Vue提供的子组件索引方法 使用特殊的属性ref来为子组件指定一个索引名称 在父组件模板中，子组件标签上使用了ref指定了一个名称ComA，并在父组件内通过this.$refs来访问ComA这个子组件 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;button @click=\"handleRef\"&gt;通过ref获取子组件实例&lt;/button&gt; &lt;my-item ref=\"comA\"&gt;&lt;/my-item&gt; &lt;/div&gt; &lt;script src=\"lib/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; Vue.component('my-item', { template: \"&lt;div&gt;子组件&lt;/div&gt;\", data: function (){ return { message: '子组件内容' } } }); var app = new Vue({ el: '#app', methods: { handleRef: function (){ var msg = this.$refs.comA.message; console.log(msg); } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/02/28/vue-com-child/"},{"title":"Vue路由笔记","text":"redirect重定位，给路由指定默认的组件，打开就是指向的默认组件 1234567var router = new VueRouter({ route: [ //这里path后不是conponent，而是用redirect指向一个组件路径 {path: '/', redirect: '/login'}, {path: '/login', conponent: login} ]}) 给激活的router-link添加高亮的两种方式 直接给默认的linkActiveClass添加样式 改变router-link的默认类，使用构造方法VueRouter中的linkActiveClass来给自定义新的类 123456var router = new VueRouter({ route: [ {path: '/login', conponent: login} ], linkActiveClass: 'myActive', //改变了默认的类，可以给这个类指定样式使得激活后高亮}) 给router-link添加参数传递的两种方式 在router-link中的to中加入参数：?id=10&amp;name=username，组件中可以通过$route.query.id和$route.query.name来获取传递的参数值 1&lt;router-link to='/login?id=10&amp;name=username'&gt;&lt;/router-link&gt; 在路由的构造函数的routes的path中使用/:name来说明这里是会有参数传递的，也可以理解为占一个位置，可以通过$route.params.id和$route.params.name获取 12345var router = new VueRouter({ routes: [ {path: '/login/:id/:name', conponent: login} ]}) ​ 传递参数： 这里的实际参数id就为10，name就是username 1&lt;router-link to='/login/10/username'&gt;&lt;/router-link&gt; 路由嵌套 ​ 在路由构造函数实例中的path中添加children指向子路由，组件中还有router-link指向子组件 12345678910111213141516171819var parent = { template: ` &lt;div&gt; Parent &lt;router-link to='/parent/son'&gt;&lt;/router-link&gt; &lt;/div&gt; `}var router = new VueRouter({ route: [ { path: '/parent', component: parent, children: [ {path: 'son', component: son} ] } ]}) 使用命名视图给路由组件添加名称，方便给每个组件渲染样式 12345&lt;div id='app'&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;router-view name='left'&gt;&lt;/router-view&gt; &lt;router-view name='main'&gt;&lt;/router-view&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526var header = { template: '&lt;h1&gt;顶部&lt;/h1&gt;'}var leftBox = { template: '&lt;h1&gt;左侧侧边栏&lt;/h1&gt;'}var rightBox = { template: '&lt;h1&gt;主体区域&lt;/h1&gt;'}var router = new VueRouter({ routes: [ { path: '/', components: { 'default': header, 'left': leftBox, 'main': rightBox } } ]})var app = new Vue({ el: '#app', router: router,})","link":"/2020/03/22/vue-component-note2/"},{"title":"Vue 组件 | 父子组件通信","text":"组件通信-父子组件的通信 文中涉及的$emit()解释：用法： $emit( eventName, […args] )eventName:事件名，会绑定一个方法。当组件触发事件后，将调用这个方法。…args: 附加参数，会被抛出，由上述绑定的方法接收使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;balance&gt;&lt;/balance&gt; &lt;/div&gt; &lt;script src=\"../lib/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; // 父组件,包含了子组件show Vue.component('balance', { template:` &lt;div&gt; //@show-balance是事件名，被下面$emit调用，执行show_balance()方法 &lt;show @show-balance=\"show_balance()\"&gt;&lt;/show&gt; &lt;div v-if=\"show\"&gt;余额： ￥ 33&lt;/div&gt; &lt;/div&gt; `, methods: { show_balance: function (){ this.show = true } }, data: function (){ return { //show变量，用于判断是否显示，默认为false，不显示 show: false } } }); &lt;!--子组件--&gt; Vue.component('show', { // 给按钮添加点击监听事件 template: ` &lt;button @click=\"on_click()\"&gt;显示余额&lt;/button&gt; `, methods: { on_click: function(){ //绑定了show-balance方法 this.$emit('show-balance') } } }); new Vue({ el: '#app', }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/02/18/vue-component/"},{"title":"Vue组件中css不能更改v-html内的样式的解决办法","text":"今天在项目中使用axios请求数据的时候，返回的内容里含有html的各种标签，使用v-html渲染到组件页面的时候发现在style里直接更改v-html内的元素的样式没有任何效果，但是删除style的scoped属性之后，就有效果了，但是这种会引起问题，scoped对渲染的范围作了限制，去掉就没有限制。针对这个问题，搜了一下，发现可以使用deep scoped来更改v-html内的样式 使用方法(举例一个div, 假设v-html中有一个类名称为content)： 123&lt;div class='container'&gt; &lt;p v-html='content'&gt;&lt;/p&gt;&lt;/div&gt; 渲染： 1234.container &gt;&gt;&gt; .content{ background-color: red; width: 300px; } 现在v-html中的.content就会有指定的样式了","link":"/2020/04/12/vue-deep-scoped/"},{"title":"Vue | 自定义指令","text":"效果： 通过自定义指令给渲染的文本添加颜色 自定义指令有两种方式：可以自定义私有`directives`或者公有指令`Vue.directive('name', {bind, inserted, updated})` 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p v-color=\"'red'\"&gt;{{ msg }}&lt;/p&gt; &lt;/div&gt; &lt;script src=\"lib/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; //定义全局指令 Vue.directive('color', { bind: function (el, binding) { // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，只执行一次 // 注意： 在每个 函数中，第一个参数，永远是 el ，表示 被绑定了指令的那个元素，这个 el 参数，是一个原生的JS对象 // 在元素 刚绑定了指令的时候，还没有 插入到 DOM中去，这时候，调用 focus 方法没有作用 // 因为，一个元素，只有插入DOM之后，才能获取焦点 //binding为传过来的参数 el.style.color = binding.value }, inserted: function (el) { // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】 // 和JS行为有关的操作，最好在 inserted 中去执行，放置 JS行为不生效 }, updated: function (el) { // 当VNode更新的时候，会执行 updated， 可能会触发多次 } }) var app = new Vue({ el: '#app', data: { msg: 'Hello Vue.js' }, //定义私有指令 // directives: { // 'color': function (el){ // el.style.color = 'red' // } // } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/03/11/vue-directive/"},{"title":"Vue filter","text":"使用过滤器过滤日期 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!--默认日期，不会刷新--&gt; 默认日期： {{ default_date }} &lt;hr&gt; &lt;!--使用过滤器过滤日期--&gt; 过滤后日期： {{ date | fromDate }} &lt;/div&gt; &lt;script src=\"lib/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; //把小于10的数变成0+这个数，例01，02 var pddDate = function (value){ return value &lt; 10 ? '0' + value : value; }; var app = new Vue({ el: '#app', data: { date: new Date(), default_date: new Date() }, // 这是一个自定义过滤器，把日期格式化一下 filters:{ fromDate: function (){ var date = new Date(); var year = pddDate(date.getFullYear()); var month = pddDate(date.getMonth() + 1); var day = pddDate(date.getDay()); var hours = pddDate(date.getHours()); var minutes = pddDate(date.getMinutes()); var seconds = pddDate(date.getSeconds()); return year + '-' + month + '-' + day + ' ' + hours + ':' + minutes + ':' + seconds; } }, mounted: function(){ //声明一个变量指向this，防止直接用this导致指向不明 var _this = this; //设置一个定时器，每秒刷新一次 setInterval(function(){ _this.date = new Date; },1000) } }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/02/18/vue-filter/"},{"title":"Vue 笔记 Day1","text":"黑马的课堂笔记总结，总共五天。附上Vue生命周期图 Day1 # Vue.js - Day1 课程介绍前5天： 都在学习Vue基本的语法和概念；打包工具 Webpack , Gulp后5天： 以项目驱动教学； 什么是Vue.js Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果； 为什么要学习流行框架 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱； 企业中，使用框架，能够提高开发的效率； 提高开发效率的发展历程：原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】） 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑； 增强自己就业时候的竞争力 人无我有，人有我优 你平时不忙的时候，都在干嘛？ 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel 为什么有了MVC还要有MVVM Vue.js 基本代码 和 MVVM 之间的对应关系Vue之 - 基本的代码结构和插值表达式、v-cloakVue指令之v-text和v-htmlVue指令之v-bind的三种用法 直接使用指令v-bind 使用简化指令: 在绑定的时候，拼接绑定内容：:title=&quot;btnTitle + ', 这是追加的内容'&quot; Vue指令之v-on和跑马灯效果跑马灯效果 HTML结构： 12345678910&lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{info}}&lt;/p&gt; &lt;input type=&quot;button&quot; value=&quot;开启&quot; v-on:click=&quot;go&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;停止&quot; v-on:click=&quot;stop&quot;&gt; &lt;/div&gt; Vue实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { info: '猥琐发育，别浪~！', intervalId: null }, methods: { go() { // 如果当前有定时器在运行，则直接return if (this.intervalId != null) { return; } // 开始定时器 this.intervalId = setInterval(() =&gt; { this.info = this.info.substring(1) + this.info.substring(0, 1); }, 500); }, stop() { clearInterval(this.intervalId); } } }); Vue指令之v-on的缩写和事件修饰符事件修饰符： .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 Vue指令之v-model和双向数据绑定简易计算器案例 HTML 代码结构 123456789101112131415161718192021222324&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;n1&quot;&gt; &lt;select v-model=&quot;opt&quot;&gt; &lt;option value=&quot;0&quot;&gt;+&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;-&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;*&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;÷&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;text&quot; v-model=&quot;n2&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;=&quot; v-on:click=&quot;getResult&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;result&quot;&gt;&lt;/div&gt; Vue实例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { n1: 0, n2: 0, result: 0, opt: '0' }, methods: { getResult() { switch (this.opt) { case '0': this.result = parseInt(this.n1) + parseInt(this.n2); break; case '1': this.result = parseInt(this.n1) - parseInt(this.n2); break; case '2': this.result = parseInt(this.n1) * parseInt(this.n2); break; case '3': this.result = parseInt(this.n1) / parseInt(this.n2); break; } } } }); 在Vue中使用样式使用class样式 数组 1&lt;h1 :class=&quot;['red', 'thin']&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中使用三元表达式 1&lt;h1 :class=&quot;['red', 'thin', isactive?'active':'']&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中嵌套对象 1&lt;h1 :class=&quot;['red', 'thin', {'active': isactive}]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 直接使用对象 1&lt;h1 :class=&quot;{red:true, italic:true, active:true, thin:true}&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 使用内联样式 直接在元素上通过 :style 的形式，书写样式对象 1&lt;h1 :style=&quot;{color: 'red', 'font-size': '40px'}&quot;&gt;这是一个善良的H1&lt;/h1&gt; 将样式对象，定义到 data 中，并直接引用到 :style 中 在data上定义样式：123data: { h1StyleObj: { color: 'red', 'font-size': '40px', 'font-weight': '200' }} 在元素中，通过属性绑定的形式，将样式对象应用到元素中：1&lt;h1 :style=&quot;h1StyleObj&quot;&gt;这是一个善良的H1&lt;/h1&gt; 在 :style 中通过数组，引用多个 data 上的样式对象 在data上定义样式：1234data: { h1StyleObj: { color: 'red', 'font-size': '40px', 'font-weight': '200' }, h1StyleObj2: { fontStyle: 'italic' }} 在元素中，通过属性绑定的形式，将样式对象应用到元素中：1&lt;h1 :style=&quot;[h1StyleObj, h1StyleObj2]&quot;&gt;这是一个善良的H1&lt;/h1&gt; Vue指令之v-for和key属性 迭代数组 123&lt;ul&gt; &lt;li v-for=&quot;(item, i) in list&quot;&gt;索引：{{i}} --- 姓名：{{item.name}} --- 年龄：{{item.age}}&lt;/li&gt;&lt;/ul&gt; 迭代对象中的属性 1234&lt;!-- 循环遍历对象身上的属性 --&gt; &lt;div v-for=&quot;(val, key, i) in userInfo&quot;&gt;{{val}} --- {{key}} --- {{i}}&lt;/div&gt; 迭代数字 12&lt;p v-for=&quot;i in 10&quot;&gt;这是第 {{i}} 个P标签&lt;/p&gt; 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 Vue指令之v-if和v-show 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。 品牌管理案例添加新品牌删除品牌根据条件筛选品牌 1.x 版本中的filterBy指令，在2.x中已经被废除： filterBy - 指令 12345678910111213141516&lt;tr v-for=&quot;item in list | filterBy searchName in 'name'&quot;&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.ctime}}&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 1234&lt;hr&gt; 输入筛选名称：&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot;&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 1234567891011121314151617181920&lt;tbody&gt; &lt;tr v-for=&quot;item in search(searchName)&quot;&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.ctime}}&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 12345678910search(name) { return this.list.filter(x =&gt; { return x.name.indexOf(name) != -1; });} Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 私有过滤器 HTML元素： 12&lt;td&gt;{{item.ctime | dataFormat('yyyy-mm-dd')}}&lt;/td&gt; 私有 filters 定义方式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344filters: { // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = &quot;&quot;) { // 在参数列表中 通过 pattern=&quot;&quot; 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') { return `${y}-${m}-${d}`; } else { // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `${y}-${m}-${d} ${hh}:${mm}:${ss}`; } } } 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器123456789101112131415161718192021222324252627282930313233343536373839404142// 定义一个全局过滤器Vue.filter('dataFormat', function (input, pattern = '') { var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') { return `${y}-${m}-${d}`; } else { // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `${y}-${m}-${d} ${hh}:${mm}:${ss}`; }}); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 键盘修饰符以及自定义键盘修饰符1.x中自定义键盘修饰符【了解即可】12Vue.directive('on').keyCodes.f2 = 113; 2.x中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： 12Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： 12&lt;input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.f2=&quot;add&quot;&gt; 自定义指令 自定义全局和局部的 自定义指令： 123456789101112131415161718192021222324252627282930313233343536// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：Vue.directive('focus', { inserted: function (el) { // inserted 表示被绑定元素插入父节点时调用 el.focus(); }});// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: { color: { // 为元素设置指定的字体颜色 bind(el, binding) { el.style.color = binding.value; } }, 'font-weight': function (el, binding2) { // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; } } 自定义指令的使用方式： 12&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot; v-focus v-color=&quot;'red'&quot; v-font-weight=&quot;900&quot;&gt; Vue 1.x 中 自定义元素指令【已废弃,了解即可】12345Vue.elementDirective('red-color', { bind: function () { this.el.style.color = 'red'; }}); 使用方式： 1&lt;red-color&gt;1232&lt;/red-color&gt; 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 Vue.js双向绑定的实现原理 Day2 # Vue.js - Day2 品牌管理案例添加新品牌删除品牌根据条件筛选品牌 1.x 版本中的filterBy指令，在2.x中已经被废除： filterBy - 指令 12345678910111213141516&lt;tr v-for=&quot;item in list | filterBy searchName in 'name'&quot;&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.ctime}}&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 1234&lt;hr&gt; 输入筛选名称：&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot;&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 1234567891011121314151617181920&lt;tbody&gt; &lt;tr v-for=&quot;item in search(searchName)&quot;&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.ctime}}&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 12345678910search(name) { return this.list.filter(x =&gt; { return x.name.indexOf(name) != -1; });} Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 私有过滤器 HTML元素： 12&lt;td&gt;{{item.ctime | dataFormat('yyyy-mm-dd')}}&lt;/td&gt; 私有 filters 定义方式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344filters: { // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = &quot;&quot;) { // 在参数列表中 通过 pattern=&quot;&quot; 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') { return `${y}-${m}-${d}`; } else { // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `${y}-${m}-${d} ${hh}:${mm}:${ss}`; } } } 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器123456789101112131415161718192021222324252627282930313233343536373839404142// 定义一个全局过滤器Vue.filter('dataFormat', function (input, pattern = '') { var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') { return `${y}-${m}-${d}`; } else { // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `${y}-${m}-${d} ${hh}:${mm}:${ss}`; }}); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 键盘修饰符以及自定义键盘修饰符1.x中自定义键盘修饰符【了解即可】12Vue.directive('on').keyCodes.f2 = 113; 2.x中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： 12Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： 12&lt;input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.f2=&quot;add&quot;&gt; 自定义指令 自定义全局和局部的 自定义指令： 123456789101112131415161718192021222324252627282930313233343536// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：Vue.directive('focus', { inserted: function (el) { // inserted 表示被绑定元素插入父节点时调用 el.focus(); }});// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: { color: { // 为元素设置指定的字体颜色 bind(el, binding) { el.style.color = binding.value; } }, 'font-weight': function (el, binding2) { // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; } } 自定义指令的使用方式： 12&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot; v-focus v-color=&quot;'red'&quot; v-font-weight=&quot;900&quot;&gt; Vue 1.x 中 自定义元素指令【已废弃,了解即可】12345Vue.elementDirective('red-color', { bind: function () { this.el.style.color = 'red'; }}); 使用方式： 1&lt;red-color&gt;1232&lt;/red-color&gt; vue实例的生命周期 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 vue-resource 实现 get, post, jsonp请求除了 vue-resource 之外，还可以使用 axios 的第三方包实现实现数据的请求 之前的学习中，如何发起数据请求？ 常见的数据请求类型？ get post jsonp 测试的URL请求资源地址： get请求地址： http://vue.studyit.io/api/getlunbo post请求地址：http://vue.studyit.io/api/post jsonp请求地址：http://vue.studyit.io/api/jsonp JSONP的实现原理 由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全； 可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）； 具体实现过程： 先在客户端定义一个回调方法，预定义对数据的操作； 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口； 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了； 带大家通过 Node.js ，来手动实现一个JSONP的请求例子；1234567891011121314151617181920212223242526272829303132333435const http = require('http');// 导入解析 URL 地址的核心模块const urlModule = require('url');const server = http.createServer();// 监听 服务器的 request 请求事件，处理每个请求server.on('request', (req, res) =&gt; { const url = req.url; // 解析客户端请求的URL地址 var info = urlModule.parse(url, true); // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据 if (info.pathname === '/getjsonp') { // 获取客户端指定的回调函数的名称 var cbName = info.query.callback; // 手动拼接要返回给客户端的数据对象 var data = { name: 'zs', age: 22, gender: '男', hobby: ['吃饭', '睡觉', '运动'] } // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法： var result = `${cbName}(${JSON.stringify(data)})`; // 将拼接好的方法的调用，返回给客户端去解析执行 res.end(result); } else { res.end('404'); }});server.listen(3000, () =&gt; { console.log('server running at http://127.0.0.1:3000');}); vue-resource 的配置步骤： 直接在页面中，通过script标签，引入 vue-resource 的脚本文件； 注意：引用的先后顺序是：先引用 Vue 的脚本文件，再引用 vue-resource 的脚本文件； 发送get请求：12345getInfo() { // get 方式获取数据 this.$http.get('http://127.0.0.1:8899/api/getlunbo').then(res =&gt; { console.log(res.body); })} 发送post请求：12345678910postInfo() { var url = 'http://127.0.0.1:8899/api/post'; // post 方法接收三个参数： // 参数1： 要请求的URL地址 // 参数2： 要发送的数据对象 // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded this.$http.post(url, { name: 'zs' }, { emulateJSON: true }).then(res =&gt; { console.log(res.body); });} 发送JSONP请求获取数据：123456jsonpInfo() { // JSONP形式从服务器获取数据 var url = 'http://127.0.0.1:8899/api/jsonp'; this.$http.jsonp(url).then(res =&gt; { console.log(res.body); });} 配置本地数据库和数据接口API 先解压安装 PHPStudy; 解压安装 Navicat 这个数据库可视化工具，并激活； 打开 Navicat 工具，新建空白数据库，名为 dtcmsdb4; 双击新建的数据库，连接上这个空白数据库，在新建的数据库上右键 -&gt; 运行SQL文件，选择并执行 dtcmsdb4.sql 这个数据库脚本文件；如果执行不报错，则数据库导入完成； 进入文件夹 vuecms3_nodejsapi 内部，执行 npm i 安装所有的依赖项； 先确保本机安装了 nodemon, 没有安装，则运行 npm i nodemon -g 进行全局安装，安装完毕后，进入到 vuecms3_nodejsapi目录 -&gt; src目录 -&gt; 双击运行 start.bat 如果API启动失败，请检查 PHPStudy 是否正常开启，同时，检查 app.js 中第 14行 中数据库连接配置字符串是否正确；PHPStudy 中默认的 用户名是root，默认的密码也是root 品牌管理改造展示品牌列表添加品牌数据删除品牌数据Vue中的动画为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能； 使用过渡类名 HTML结构：1234567&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;动起来&quot; @click=&quot;myAnimate&quot;&gt; &lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;div v-show=&quot;isshow&quot;&gt;动画哦&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; VM 实例：123456789101112// 创建 Vue 实例，得到 ViewModelvar vm = new Vue({ el: '#app', data: { isshow: false }, methods: { myAnimate() { this.isshow = !this.isshow; } }}); 定义两组类样式：12345678910111213/* 定义进入和离开时候的过渡状态 */ .fade-enter-active, .fade-leave-active { transition: all 0.2s ease; position: absolute; } /* 定义进入过渡的开始状态 和 离开过渡的结束状态 */ .fade-enter, .fade-leave-to { opacity: 0; transform: translateX(100px); } 使用第三方 CSS 动画库 导入动画类库：1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./lib/animate.css&quot;&gt; 定义 transition 及属性：123456&lt;transition enter-active-class=&quot;fadeInRight&quot; leave-active-class=&quot;fadeOutRight&quot; :duration=&quot;{ enter: 500, leave: 800 }&quot;&gt; &lt;div class=&quot;animated&quot; v-show=&quot;isshow&quot;&gt;动画哦&lt;/div&gt;&lt;/transition&gt; 使用动画钩子函数 定义 transition 组件以及三个钩子函数：123456789&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;切换动画&quot; @click=&quot;isshow = !isshow&quot;&gt; &lt;transition @before-enter=&quot;beforeEnter&quot; @enter=&quot;enter&quot; @after-enter=&quot;afterEnter&quot;&gt; &lt;div v-if=&quot;isshow&quot; class=&quot;show&quot;&gt;OK&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; 定义三个 methods 钩子方法：12345678910111213methods: { beforeEnter(el) { // 动画进入之前的回调 el.style.transform = 'translateX(500px)'; }, enter(el, done) { // 动画进入完成时候的回调 el.offsetWidth; el.style.transform = 'translateX(0px)'; done(); }, afterEnter(el) { // 动画进入完成之后的回调 this.isshow = !this.isshow; } } 定义动画过渡时长和样式：123.show{ transition: all 0.4s ease; } v-for 的列表过渡 定义过渡样式：123456789101112&lt;style&gt; .list-enter, .list-leave-to { opacity: 0; transform: translateY(10px); } .list-enter-active, .list-leave-active { transition: all 0.3s ease; }&lt;/style&gt; 定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来：1234567&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;txt&quot; @keyup.enter=&quot;add&quot;&gt; &lt;transition-group tag=&quot;ul&quot; name=&quot;list&quot;&gt; &lt;li v-for=&quot;(item, i) in list&quot; :key=&quot;i&quot;&gt;{{item}}&lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt; 定义 VM中的结构：1234567891011121314// 创建 Vue 实例，得到 ViewModelvar vm = new Vue({ el: '#app', data: { txt: '', list: [1, 2, 3, 4] }, methods: { add() { this.list.push(this.txt); this.txt = ''; } }}); 列表的排序过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。 v-move 和 v-leave-active 结合使用，能够让列表的过渡更加平缓柔和：123456.v-move{ transition: all 0.8s ease;}.v-leave-active{ position: absolute;} 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 pagekit/vue-resource navicat如何导入sql文件和导出sql文件 贝塞尔在线生成器 Day3 # Vue.js - Day3 定义Vue组件什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；组件化和模块化的不同： 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一； 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；全局组件定义的三种方式 使用 Vue.extend 配合 Vue.component 方法：1234var login = Vue.extend({ template: '&lt;h1&gt;登录&lt;/h1&gt;' }); Vue.component('login', login); 直接使用 Vue.component 方法：123Vue.component('register', { template: '&lt;h1&gt;注册&lt;/h1&gt;' }); 将模板字符串，定义到script标签种：123&lt;script id=&quot;tmpl&quot; type=&quot;x-template&quot;&gt; &lt;div&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;&lt;/div&gt; &lt;/script&gt; 同时，需要使用 Vue.component 来定义组件：123Vue.component('account', { template: '#tmpl' }); 注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！ 组件中展示数据和响应事件 在组件中，data需要被定义为一个方法，例如：12345678910111213Vue.component('account', { template: '#tmpl', data() { return { msg: '大家好！' } }, methods:{ login(){ alert('点击了登录按钮'); } } }); 在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的data属性中的值，需要使用this来访问； 【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象 通过计数器案例演示 使用components属性定义局部子组件 组件实例定义方式：123456789101112131415161718&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: {}, components: { // 定义子组件 account: { // account 组件 template: '&lt;div&gt;&lt;h1&gt;这是Account组件{{name}}&lt;/h1&gt;&lt;login&gt;&lt;/login&gt;&lt;/div&gt;', // 在这里使用定义的子组件 components: { // 定义子组件的子组件 login: { // login 组件 template: &quot;&lt;h3&gt;这是登录组件&lt;/h3&gt;&quot; } } } } }); &lt;/script&gt; 引用组件：123&lt;div id=&quot;app&quot;&gt; &lt;account&gt;&lt;/account&gt; &lt;/div&gt; 使用flag标识符结合v-if和v-else切换组件 页面结构：12345&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;&gt; &lt;my-com1 v-if=&quot;flag&quot;&gt;&lt;/my-com1&gt; &lt;my-com2 v-else=&quot;flag&quot;&gt;&lt;/my-com2&gt; &lt;/div&gt; Vue实例定义：123456789101112131415161718&lt;script&gt; Vue.component('myCom1', { template: '&lt;h3&gt;奔波霸&lt;/h3&gt;' }) Vue.component('myCom2', { template: '&lt;h3&gt;霸波奔&lt;/h3&gt;' }) // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { flag: true }, methods: {} }); &lt;/script&gt; 使用:is属性来切换不同的子组件,并添加切换动画 组件实例定义方式：12345678910111213141516171819202122// 登录组件 const login = Vue.extend({ template: `&lt;div&gt; &lt;h3&gt;登录组件&lt;/h3&gt; &lt;/div&gt;` }); Vue.component('login', login); // 注册组件 const register = Vue.extend({ template: `&lt;div&gt; &lt;h3&gt;注册组件&lt;/h3&gt; &lt;/div&gt;` }); Vue.component('register', register); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { comName: 'login' }, methods: {} }); 使用component标签，来引用组件，并通过:is属性来指定要加载的组件：12345678&lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;comName='login'&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;comName='register'&quot;&gt;注册&lt;/a&gt; &lt;hr&gt; &lt;transition mode=&quot;out-in&quot;&gt; &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt; &lt;/transition&gt;&lt;/div&gt; 添加切换样式：1234567891011121314151617&lt;style&gt; .v-enter, .v-leave-to { opacity: 0; transform: translateX(30px); } .v-enter-active, .v-leave-active { position: absolute; transition: all 0.3s ease; } h3{ margin: 0; }&lt;/style&gt; 父组件向子组件传值 组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据123456789101112131415&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { msg: '这是父组件中的消息' }, components: { son: { template: '&lt;h1&gt;这是子组件 --- {{finfo}}&lt;/h1&gt;', props: ['finfo'] } } }); &lt;/script&gt; 使用v-bind或简化指令，将数据传递到子组件中：123&lt;div id=&quot;app&quot;&gt; &lt;son :finfo=&quot;msg&quot;&gt;&lt;/son&gt; &lt;/div&gt; 子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称1&lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt; 子组件内部通过this.$emit('方法名', 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用12345678910111213141516171819202122232425262728293031323334&lt;div id=&quot;app&quot;&gt; &lt;!-- 引用父组件 --&gt; &lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt; &lt;!-- 组件模板定义 --&gt; &lt;script type=&quot;x-template&quot; id=&quot;son&quot;&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;向父组件传值&quot; @click=&quot;sendMsg&quot; /&gt; &lt;/div&gt; &lt;/script&gt; &lt;/div&gt; &lt;script&gt; // 子组件的定义方式 Vue.component('son', { template: '#son', // 组件模板Id methods: { sendMsg() { // 按钮的点击事件 this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去 } } }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: { getMsg(val){ // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义 alert(val); } } }); &lt;/script&gt; 评论列表案例目标：主要练习父子组件之间传值 使用 this.$refs 来获取元素和组件123456789101112131415161718192021222324252627282930313233343536&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;获取元素内容&quot; @click=&quot;getElement&quot; /&gt; &lt;!-- 使用 ref 获取元素 --&gt; &lt;h1 ref=&quot;myh1&quot;&gt;这是一个大大的H1&lt;/h1&gt; &lt;hr&gt; &lt;!-- 使用 ref 获取子组件 --&gt; &lt;my-com ref=&quot;mycom&quot;&gt;&lt;/my-com&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-com', { template: '&lt;h5&gt;这是一个子组件&lt;/h5&gt;', data() { return { name: '子组件' } } }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: { getElement() { // 通过 this.$refs 来获取元素 console.log(this.$refs.myh1.innerText); // 通过 this.$refs 来获取组件 console.log(this.$refs.mycom.name); } } });&lt;/script&gt; 什么是路由 对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； 在 vue 中使用 vue-router 导入 vue-router 组件类库：12&lt;!-- 1. 导入 vue-router 组件类库 --&gt; &lt;script src=&quot;./lib/vue-router-2.7.0.js&quot;&gt;&lt;/script&gt; 使用 router-link 组件来导航123&lt;!-- 2. 使用 router-link 组件来导航 --&gt;&lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; 使用 router-view 组件来显示匹配到的组件12&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 创建使用Vue.extend创建组件123456789// 4.1 使用 Vue.extend 来创建登录组件var login = Vue.extend({ template: '&lt;h1&gt;登录组件&lt;/h1&gt;'});// 4.2 使用 Vue.extend 来创建注册组件var register = Vue.extend({ template: '&lt;h1&gt;注册组件&lt;/h1&gt;'}); 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则1234567// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 var router = new VueRouter({ routes: [ { path: '/login', component: login }, { path: '/register', component: register } ] }); 使用 router 属性来使用路由规则12345// 6. 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', router: router // 使用 router 属性来使用路由规则 }); 设置路由高亮设置路由切换动效在路由规则中定义参数 在规则中定义参数：1{ path: '/register/:id', component: register } 通过 this.$route.params来获取路由中的参数：123var register = Vue.extend({ template: '&lt;h1&gt;注册组件 --- {{this.$route.params.id}}&lt;/h1&gt;' }); 使用 children 属性实现路由嵌套1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/account&quot;&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; // 父路由中的组件 const account = Vue.extend({ template: `&lt;div&gt; 这是account组件 &lt;router-link to=&quot;/account/login&quot;&gt;login&lt;/router-link&gt; | &lt;router-link to=&quot;/account/register&quot;&gt;register&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;` }); // 子路由中的 login 组件 const login = Vue.extend({ template: '&lt;div&gt;登录组件&lt;/div&gt;' }); // 子路由中的 register 组件 const register = Vue.extend({ template: '&lt;div&gt;注册组件&lt;/div&gt;' }); // 路由实例 var router = new VueRouter({ routes: [ { path: '/', redirect: '/account/login' }, // 使用 redirect 实现路由重定向 { path: '/account', component: account, children: [ // 通过 children 数组属性，来实现路由的嵌套 { path: 'login', component: login }, // 注意，子路由的开头位置，不要加 / 路径符 { path: 'register', component: register } ] } ] }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: {}, components: { account }, router: router });&lt;/script&gt; 命名视图实现经典布局 标签代码结构：1234567&lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class=&quot;content&quot;&gt; &lt;router-view name=&quot;a&quot;&gt;&lt;/router-view&gt; &lt;router-view name=&quot;b&quot;&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; JS代码：12345678910111213141516171819202122232425262728293031323334&lt;script&gt; var header = Vue.component('header', { template: '&lt;div class=&quot;header&quot;&gt;header&lt;/div&gt;' }); var sidebar = Vue.component('sidebar', { template: '&lt;div class=&quot;sidebar&quot;&gt;sidebar&lt;/div&gt;' }); var mainbox = Vue.component('mainbox', { template: '&lt;div class=&quot;mainbox&quot;&gt;mainbox&lt;/div&gt;' }); // 创建路由对象 var router = new VueRouter({ routes: [ { path: '/', components: { default: header, a: sidebar, b: mainbox } } ] }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: {}, router }); &lt;/script&gt; CSS 样式：12345678910111213141516171819&lt;style&gt; .header { border: 1px solid red; } .content{ display: flex; } .sidebar { flex: 2; border: 1px solid green; height: 500px; } .mainbox{ flex: 8; border: 1px solid blue; height: 500px; }&lt;/style&gt; watch属性的使用考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？） 监听data中属性的改变：1234567891011121314151617181920212223242526&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; = &lt;span&gt;{{fullName}}&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { firstName: 'jack', lastName: 'chen', fullName: 'jack - chen' }, methods: {}, watch: { 'firstName': function (newVal, oldVal) { // 第一个参数是新数据，第二个参数是旧数据 this.fullName = newVal + ' - ' + this.lastName; }, 'lastName': function (newVal, oldVal) { this.fullName = this.firstName + ' - ' + newVal; } } }); &lt;/script&gt; 监听路由对象的改变：1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = Vue.extend({ template: '&lt;h1&gt;登录组件&lt;/h1&gt;' }); var register = Vue.extend({ template: '&lt;h1&gt;注册组件&lt;/h1&gt;' }); var router = new VueRouter({ routes: [ { path: &quot;/login&quot;, component: login }, { path: &quot;/register&quot;, component: register } ] }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: {}, router: router, watch: { '$route': function (newVal, oldVal) { if (newVal.path === '/login') { console.log('这是登录组件'); } } } }); &lt;/script&gt; computed计算属性的使用 默认只有getter的计算属性：12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; = &lt;span&gt;{{fullName}}&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { firstName: 'jack', lastName: 'chen' }, methods: {}, computed: { // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值 fullName() { return this.firstName + ' - ' + this.lastName; } } }); &lt;/script&gt; 定义有getter和setter的计算属性：123456789101112131415161718192021222324252627282930313233343536&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt; &lt;input type=&quot;button&quot; value=&quot;修改fullName&quot; @click=&quot;changeName&quot;&gt; &lt;span&gt;{{fullName}}&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { firstName: 'jack', lastName: 'chen' }, methods: { changeName() { this.fullName = 'TOM - chen2'; } }, computed: { fullName: { get: function () { return this.firstName + ' - ' + this.lastName; }, set: function (newVal) { var parts = newVal.split(' - '); this.firstName = parts[0]; this.lastName = parts[1]; } } } }); &lt;/script&gt; watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； nrm的安装使用作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样； 运行npm i nrm -g全局安装nrm包； 使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 使用nrm use npm或nrm use taobao切换不同的镜像源地址； 相关文件 URL中的hash（井号） Day4 # Vue.js - Day4 父组件向子组件传值 组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据123456789101112131415&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { msg: '这是父组件中的消息' }, components: { son: { template: '&lt;h1&gt;这是子组件 --- {{finfo}}&lt;/h1&gt;', props: ['finfo'] } } }); &lt;/script&gt; 使用v-bind或简化指令，将数据传递到子组件中：123&lt;div id=&quot;app&quot;&gt; &lt;son :finfo=&quot;msg&quot;&gt;&lt;/son&gt; &lt;/div&gt; 子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称1&lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt; 子组件内部通过this.$emit('方法名', 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用12345678910111213141516171819202122232425262728293031323334&lt;div id=&quot;app&quot;&gt; &lt;!-- 引用父组件 --&gt; &lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt; &lt;!-- 组件模板定义 --&gt; &lt;script type=&quot;x-template&quot; id=&quot;son&quot;&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;向父组件传值&quot; @click=&quot;sendMsg&quot; /&gt; &lt;/div&gt; &lt;/script&gt; &lt;/div&gt; &lt;script&gt; // 子组件的定义方式 Vue.component('son', { template: '#son', // 组件模板Id methods: { sendMsg() { // 按钮的点击事件 this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去 } } }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: { getMsg(val){ // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义 alert(val); } } }); &lt;/script&gt; 组件中data和props的区别评论列表案例目标：主要练习父子组件之间传值 使用 this.$refs 来获取元素和组件123456789101112131415161718192021222324252627282930313233343536&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;获取元素内容&quot; @click=&quot;getElement&quot; /&gt; &lt;!-- 使用 ref 获取元素 --&gt; &lt;h1 ref=&quot;myh1&quot;&gt;这是一个大大的H1&lt;/h1&gt; &lt;hr&gt; &lt;!-- 使用 ref 获取子组件 --&gt; &lt;my-com ref=&quot;mycom&quot;&gt;&lt;/my-com&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-com', { template: '&lt;h5&gt;这是一个子组件&lt;/h5&gt;', data() { return { name: '子组件' } } }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: { getElement() { // 通过 this.$refs 来获取元素 console.log(this.$refs.myh1.innerText); // 通过 this.$refs 来获取组件 console.log(this.$refs.mycom.name); } } });&lt;/script&gt; 什么是路由 后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； 在 vue 中使用 vue-router 导入 vue-router 组件类库：12&lt;!-- 1. 导入 vue-router 组件类库 --&gt; &lt;script src=&quot;./lib/vue-router-2.7.0.js&quot;&gt;&lt;/script&gt; 使用 router-link 组件来导航123&lt;!-- 2. 使用 router-link 组件来导航 --&gt;&lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; 使用 router-view 组件来显示匹配到的组件12&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 创建使用Vue.extend创建组件123456789// 4.1 使用 Vue.extend 来创建登录组件var login = Vue.extend({ template: '&lt;h1&gt;登录组件&lt;/h1&gt;'});// 4.2 使用 Vue.extend 来创建注册组件var register = Vue.extend({ template: '&lt;h1&gt;注册组件&lt;/h1&gt;'}); 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则1234567// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 var router = new VueRouter({ routes: [ { path: '/login', component: login }, { path: '/register', component: register } ] }); 使用 router 属性来使用路由规则12345// 6. 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', router: router // 使用 router 属性来使用路由规则 }); 使用tag属性指定router-link渲染的标签类型设置路由重定向设置路由高亮设置路由切换动效在路由规则中定义参数 在规则中定义参数：1{ path: '/register/:id', component: register } 通过 this.$route.params来获取路由中的参数：123var register = Vue.extend({ template: '&lt;h1&gt;注册组件 --- {{this.$route.params.id}}&lt;/h1&gt;' }); 使用 children 属性实现路由嵌套1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/account&quot;&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; // 父路由中的组件 const account = Vue.extend({ template: `&lt;div&gt; 这是account组件 &lt;router-link to=&quot;/account/login&quot;&gt;login&lt;/router-link&gt; | &lt;router-link to=&quot;/account/register&quot;&gt;register&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;` }); // 子路由中的 login 组件 const login = Vue.extend({ template: '&lt;div&gt;登录组件&lt;/div&gt;' }); // 子路由中的 register 组件 const register = Vue.extend({ template: '&lt;div&gt;注册组件&lt;/div&gt;' }); // 路由实例 var router = new VueRouter({ routes: [ { path: '/', redirect: '/account/login' }, // 使用 redirect 实现路由重定向 { path: '/account', component: account, children: [ // 通过 children 数组属性，来实现路由的嵌套 { path: 'login', component: login }, // 注意，子路由的开头位置，不要加 / 路径符 { path: 'register', component: register } ] } ] }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: {}, components: { account }, router: router });&lt;/script&gt; 命名视图实现经典布局 标签代码结构：1234567&lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class=&quot;content&quot;&gt; &lt;router-view name=&quot;a&quot;&gt;&lt;/router-view&gt; &lt;router-view name=&quot;b&quot;&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; JS代码：12345678910111213141516171819202122232425262728293031323334&lt;script&gt; var header = Vue.component('header', { template: '&lt;div class=&quot;header&quot;&gt;header&lt;/div&gt;' }); var sidebar = Vue.component('sidebar', { template: '&lt;div class=&quot;sidebar&quot;&gt;sidebar&lt;/div&gt;' }); var mainbox = Vue.component('mainbox', { template: '&lt;div class=&quot;mainbox&quot;&gt;mainbox&lt;/div&gt;' }); // 创建路由对象 var router = new VueRouter({ routes: [ { path: '/', components: { default: header, a: sidebar, b: mainbox } } ] }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: {}, router }); &lt;/script&gt; CSS 样式：12345678910111213141516171819&lt;style&gt; .header { border: 1px solid red; } .content{ display: flex; } .sidebar { flex: 2; border: 1px solid green; height: 500px; } .mainbox{ flex: 8; border: 1px solid blue; height: 500px; }&lt;/style&gt; watch属性的使用考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？） 监听data中属性的改变：1234567891011121314151617181920212223242526&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; = &lt;span&gt;{{fullName}}&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { firstName: 'jack', lastName: 'chen', fullName: 'jack - chen' }, methods: {}, watch: { 'firstName': function (newVal, oldVal) { // 第一个参数是新数据，第二个参数是旧数据 this.fullName = newVal + ' - ' + this.lastName; }, 'lastName': function (newVal, oldVal) { this.fullName = this.firstName + ' - ' + newVal; } } }); &lt;/script&gt; 监听路由对象的改变：1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = Vue.extend({ template: '&lt;h1&gt;登录组件&lt;/h1&gt;' }); var register = Vue.extend({ template: '&lt;h1&gt;注册组件&lt;/h1&gt;' }); var router = new VueRouter({ routes: [ { path: &quot;/login&quot;, component: login }, { path: &quot;/register&quot;, component: register } ] }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: {}, methods: {}, router: router, watch: { '$route': function (newVal, oldVal) { if (newVal.path === '/login') { console.log('这是登录组件'); } } } }); &lt;/script&gt; computed计算属性的使用 默认只有getter的计算属性：12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; = &lt;span&gt;{{fullName}}&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { firstName: 'jack', lastName: 'chen' }, methods: {}, computed: { // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值 fullName() { return this.firstName + ' - ' + this.lastName; } } }); &lt;/script&gt; 定义有getter和setter的计算属性：123456789101112131415161718192021222324252627282930313233343536&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt; &lt;input type=&quot;button&quot; value=&quot;修改fullName&quot; @click=&quot;changeName&quot;&gt; &lt;span&gt;{{fullName}}&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { firstName: 'jack', lastName: 'chen' }, methods: { changeName() { this.fullName = 'TOM - chen2'; } }, computed: { fullName: { get: function () { return this.firstName + ' - ' + this.lastName; }, set: function (newVal) { var parts = newVal.split(' - '); this.firstName = parts[0]; this.lastName = parts[1]; } } } }); &lt;/script&gt; watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； nrm的安装使用作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样； 运行npm i nrm -g全局安装nrm包； 使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 使用nrm use npm或nrm use taobao切换不同的镜像源地址； 相关文件 URL中的hash（井号） Day5 # Vue.js - Day5 - Webpack 在网页中会引用哪些常见的静态资源？ JS .js .jsx .coffee .ts（TypeScript 类 C# 语言） CSS .css .less .sass .scss Images .jpg .png .gif .bmp .svg 字体文件（Fonts） .svg .ttf .eot .woff .woff2 模板文件 .ejs .jade .vue【这是在webpack中定义组件的方式，推荐这么用】 网页中引入的静态资源多了以后有什么问题？？？ 网页加载速度慢， 因为 我们要发起很多的二次请求； 要处理错综复杂的依赖关系 如何解决上述两个问题 合并、压缩、精灵图、图片的Base64编码 可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系； 什么是webpack?webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具； 如何完美实现上述的2种解决方案 使用Gulp， 是基于 task 任务的； 使用Webpack， 是基于整个项目进行构建的； 借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。 根据官网的图片介绍webpack打包的过程 webpack官网 webpack安装的两种方式 运行npm i webpack -g全局安装webpack，这样就能在全局使用webpack的命令 在项目根目录中运行npm i webpack --save-dev安装到项目依赖中 初步使用webpack打包构建列表隔行变色案例 运行npm init初始化项目，使用npm管理项目中的依赖包 创建项目基本的目录结构 使用cnpm i jquery --save安装jquery类库 创建main.js并书写各行变色的代码逻辑：1234567// 导入jquery类库 import $ from 'jquery' // 设置偶数行背景色，索引从0开始，0是偶数 $('#list li:even').css('backgroundColor','lightblue'); // 设置奇数行背景色 $('#list li:odd').css('backgroundColor','pink'); 直接在页面上引用main.js会报错，因为浏览器不认识import这种高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法； 运行webpack 入口文件路径 输出文件路径对main.js进行处理：1webpack src/js/main.js dist/bundle.js 使用webpack的配置文件简化打包时候的命令 在项目根目录中创建webpack.config.js 由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在webpack.config.js中配置这两个路径：1234567891011// 导入处理路径的模块var path = require('path');// 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理module.exports = { entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件 output: { // 配置输出选项 path: path.resolve(__dirname, 'dist'), // 配置输出的路径 filename: 'bundle.js' // 配置输出的文件名 }} 实现webpack的实时打包构建 由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用webpack-dev-server来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。 运行cnpm i webpack-dev-server --save-dev安装到开发依赖 安装完成之后，在命令行直接运行webpack-dev-server来进行打包，发现报错，此时需要借助于package.json文件中的指令，来进行运行webpack-dev-server命令，在scripts节点下新增&quot;dev&quot;: &quot;webpack-dev-server&quot;指令，发现可以进行实时打包，但是dist目录下并没有生成bundle.js文件，这是因为webpack-dev-server将打包好的文件放在了内存中 把bundle.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快 这个时候访问webpack-dev-server启动的http://localhost:8080/网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，此时引用不到bundle.js文件，需要修改index.html中script的src属性为:&lt;script src=&quot;../bundle.js&quot;&gt;&lt;/script&gt; 为了能在访问http://localhost:8080/的时候直接访问到index首页，可以使用--contentBase src指令来修改dev指令，指定启动的根目录：1&quot;dev&quot;: &quot;webpack-dev-server --contentBase src&quot; 同时修改index页面中script的src属性为&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 使用html-webpack-plugin插件配置启动页面由于使用--contentBase指令的过程比较繁琐，需要指定启动的目录，同时还需要修改index.html中script标签的src属性，所以推荐大家使用html-webpack-plugin插件配置启动页面. 运行cnpm i html-webpack-plugin --save-dev安装到开发依赖 修改webpack.config.js配置文件如下：123456789101112131415161718// 导入处理路径的模块var path = require('path');// 导入自动生成HTMl文件的插件var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = { entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件 output: { // 配置输出选项 path: path.resolve(__dirname, 'dist'), // 配置输出的路径 filename: 'bundle.js' // 配置输出的文件名 }, plugins:[ // 添加plugins节点配置插件 new htmlWebpackPlugin({ template:path.resolve(__dirname, 'src/index.html'),//模板路径 filename:'index.html'//自动生成的HTML文件的名称 }) ]} 修改package.json中script节点中的dev指令如下：1&quot;dev&quot;: &quot;webpack-dev-server&quot; 将index.html中script标签注释掉，因为html-webpack-plugin插件会自动把bundle.js注入到index.html页面中！ 实现自动打开浏览器、热更新和配置浏览器的默认端口号注意：热更新在JS中表现的不明显，可以从一会儿要讲到的CSS身上进行介绍说明！ 方式1： 修改package.json的script节点如下，其中--open表示自动打开浏览器，--port 4321表示打开的端口号为4321，--hot表示启用浏览器热更新：1&quot;dev&quot;: &quot;webpack-dev-server --hot --port 4321 --open&quot; 方式2： 修改webpack.config.js文件，新增devServer节点如下：12345devServer:{ hot:true, open:true, port:4321 } 在头部引入webpack模块：1var webpack = require('webpack'); 在plugins节点下新增：1new webpack.HotModuleReplacementPlugin() 使用webpack打包css文件 运行cnpm i style-loader css-loader --save-dev 修改webpack.config.js这个配置文件：12345module: { // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 { test: /\\.css$/, use: ['style-loader', 'css-loader'] }//处理css文件的规则 ] } 注意：use表示使用哪些模块来处理test所匹配到的文件；use中相关loader模块的调用顺序是从后向前调用的； 使用webpack打包less文件 运行cnpm i less-loader less -D 修改webpack.config.js这个配置文件：1{ test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] }, 使用webpack打包sass文件 运行cnpm i sass-loader node-sass --save-dev 在webpack.config.js中添加处理sass文件的loader模块：1{ test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] } 使用webpack处理css中的路径 运行cnpm i url-loader file-loader --save-dev 在webpack.config.js中添加处理url路径的loader模块：1{ test: /\\.(png|jpg|gif)$/, use: 'url-loader' } 可以通过limit指定进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码：1{ test: /\\.(png|jpg|gif)$/, use: 'url-loader?limit=43960' }, 使用babel处理高级JS语法 运行cnpm i babel-core babel-loader babel-plugin-transform-runtime --save-dev安装babel的相关loader包 运行cnpm i babel-preset-es2015 babel-preset-stage-0 --save-dev安装babel转换的语法 在webpack.config.js中添加相关loader模块，其中需要注意的是，一定要把node_modules文件夹添加到排除项：1{ test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/ } 在项目根目录中添加.babelrc文件，并修改这个配置文件如下：1234{ &quot;presets&quot;:[&quot;es2015&quot;, &quot;stage-0&quot;], &quot;plugins&quot;:[&quot;transform-runtime&quot;]} 注意：语法插件babel-preset-es2015可以更新为babel-preset-env，它包含了所有的ES相关的语法； 相关文章babel-preset-env：你需要的唯一Babel插件Runtime transform 运行时编译es6","link":"/2020/03/13/vue-heima-1/"},{"title":"Vue.js入门","text":"Vue基础的指令 **v-for** 12345&lt;div id=\"player\"&gt; &lt;ul&gt; &lt;li v-for=\"player in nba\"&gt;{{ player.name }}&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 12345678910var player = new Vue({ el: '#player', data: { nba: [ { name: 'Dwyane Wade' }, { name: 'Lebron James' }, { name: 'Anthony Davis' } ] }}) **v-on 和 v-if** 123&lt;div id=\"app\"&gt; &lt;button v-if=\"showBtn\" v-on:click=\"handleClick\"&gt;Click me&lt;/button&gt;&lt;/div&gt; 1234567891011new Vue({ el: '#app', data:{ showBtn: true }, methods:{ handleClick: function(){ console.log('Clicked!'); } }}) **v-model 双向数据绑定** 123456789101112&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"name\" placeholder=\"请输入您的名字\"&gt; &lt;h1&gt;你好, {{ name }}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { name: '' } })&lt;/script&gt; vue实现文字滚动显示效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;div id=\"app\"&gt; &lt;!--v-on可以缩写例如：v-on:click | 缩写为: @click --&gt; &lt;input type=\"button\" value=\"MoveIt\" @click=\"move()\"&gt; &lt;input type=\"button\" value=\"SlowIt\" v-on:click=\"stop()\"&gt; &lt;input type=\"button\" value=\"UseThis\" v-on:click=\"usethis()\"&gt; &lt;h3&gt;{{ text }}&lt;/h3&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: '#app', data: { text: 'I will success!', intervalId: null //在data上定义一个定时器的ID,方便methods中访问并改变值 }, methods: { move(){ var _this = this //防止this指向不明 if(this.intervalId != null) return; this.intervalId = setInterval(function(){ //在vue实例中,要获取data上的数据,或者想要调用methods里面的方法,需要用到this来调用 var start = _this.text.substring(0,1); //获取到text的头一个字符 var end = _this.text.substring(1); //获取到text的最后一个字符 _this.text = end + start; //重新拼接得到新的字符串,赋值给this.text //注意: 这个app的vue实例会自动监听自己身上data中所有数据的改变, //只要数据一发生改变,就会自动把最新的数据从data中同步到页面中去, //[好处：只需要关心数据，不需要考虑如何重新渲染DOM页面] },100) }, stop(){ clearInterval(this.intervalId); this.intervalId = null; }, usethis: function(){ alert(this.text); //这里的text是data中的text的值 } } }) &lt;/script&gt;`","link":"/2019/11/05/Vue-js-Learn/"},{"title":"Vue mixins的厉害","text":"mixins:混合 用处：当有多个组件使用了相同方法或变量，就可以用mixins来把相同的变量或方法封装到一个对象里，哪个组件需要就可以使用mixins: [mixins对象名]来调用啦 一处定义，多处复用 使用了mixins 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;div id=\"app\"&gt; &lt;popup&gt;&lt;/popup&gt; &lt;toggle&gt;&lt;/toggle&gt;&lt;/div&gt;&lt;!----&gt;&lt;template id='popup'&gt; &lt;div&gt; &lt;h1 @mouseenter='show' @mouseleave='hide'&gt;HeiHei&lt;/h1&gt; &lt;p v-if='visible' class=\"para\"&gt;This is hide COntent&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id='toggle'&gt; &lt;div&gt; &lt;button @click='isVisible'&gt;Visible&lt;/button&gt; &lt;p v-if='visible'&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Tempora itaque nesciunt voluptates, facilis corrupti quisquam maxime numquam odio nihil amet dolorum praesentium quibusdam dolor odit qui a, fuga quod soluta?&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=\"lib/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; //声明一个名为base的对象，用来装会被复用的变量和方法，声明一次，多处使用 var base = { data: function (){ return { visible: false } }, methods: { show:function (){ this.visible = true; }, hide: function (){ this.visible = false; }, isVisible: function (){ this.visible = !this.visible; } } }; Vue.component('popup', { template: '#popup', //调用base对象，直接调用base内的变量和方法 mixins: [base] }) Vue.component('toggle', { template: '#toggle', //调用base对象，直接调用base内的变量和方法 mixins: [base] }); new Vue({ el: '#app' })&lt;/script&gt; --- 没有使用mixins 12345678910111213141516171819202122232425262728293031323334&lt;script&gt; Vue.component('popup', { template: '#popup', data: function (){ return { visible: false } }, methods: { show:function (){ this.visible = true; }, hide: function (){ this.visible = false; } } }) Vue.component('toggle', { template: '#toggle', data: function (){ return { visible: false } }, methods: { isVisible: function (){ this.visible = !this.visible; } } }); new Vue({ el: '#app' }) &lt;/script&gt;","link":"/2020/02/28/vue-mixins/"},{"title":"Vue-笔记","text":"在Vue学习中的笔记 笔记1： 1var _this = this; //这句话可以用于防止直接用this导致指向不明&gt; v-cloak解决闪动问题 通过给涉及到的元素加上一个v-cloak来解决 123[v-cloak]{ display: none;} 12345678&lt;div id=\"app\" v-cloak&gt; &lt;p&gt;{{ msg }}&lt;/p&gt; &lt;my-com&gt; &lt;template slot-scope='props'&gt; &lt;p&gt;{{ props.msg }}&lt;/p&gt; &lt;/template&gt; &lt;/my-com&gt;&lt;/div&gt;","link":"/2020/02/11/vue-notebook/"},{"title":"Vue 组件通信 | 平行组件的通信","text":"一个兄弟组件之间的通信 代码中有两个平行组件ming,huahua，ming组件的内容可以传到huahua组件，huahua可以获取ming传输的内容ming组件内通过给input元素绑定监听事件keyup来获取用户状态，当用户在input里输入内容，就会触发$emit调用on_change()函数，发送this.i_said的数据，再在huahua的组件中通过$on来监听$emit传出的数据，并使用回调函数把获取到的data赋值给huahua_said，就完成了平行组件之间的通信关键点： 在JavaScript里第一行声明了一个名为Event的空Vue实例，作为一个中间量，用来让两个平行组件通信； 下面为代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"\"&gt; &lt;style media=\"screen\"&gt; #app{ width: 230px; height: 65px; box-shadow: 0 0 30px rgba(0, 0, 0, 0.1); border-radius: 10px; font-family: 'XHei'; padding: 20px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;ming style=\"margin-bottom: 20px \"&gt;&lt;/ming&gt; &lt;huahua&gt;&lt;/huahua&gt; &lt;/div&gt; &lt;script src=\"lib/vue.js\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; //这里的Event很关键，声明一个名为Event的空Vue实例，作为一个中间量，用来让两个平行组件通信； var Event = new Vue(); Vue.component('ming',{ template: ` &lt;div&gt; 我说：&lt;input @keyup='on_change()' v-model='i_said' type=\"text\" /&gt; &lt;/div&gt; `, data: function (){ return { i_said: '' } }, methods: { //当用户在input中输入内容，就会触发i_said_something事件，并将i_said的数据发送出去 on_change: function (){ Event.$emit('i_said_something', this.i_said) } } }); Vue.component('huahua', { template: ` &lt;div&gt; 花花说： {{ huahua_said }} &lt;/div&gt; `, data: function (){ return { huahua_said: '' } }, //在生命周期mounted钩子函数里监听了来自Event的时间i_said_something mounted: function (){ var _this = this; Event.$on('i_said_something', function (data){ _this.huahua_said = data; }) } }) new Vue({ el: '#app' }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/02/22/vue-practice/"},{"title":"Vue 自己的小练习","text":"结合v-bind指令做的一个相册组件 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; .img{ width: 512px; height: 360px; border-radius: 5px; overflow: hidden; } .img:hover{ } *{ margin: 0; padding: 0; text-align: center; } .wrap{ } .photo_show{ display: block; width: 700px; height: 360px; padding: 19px; box-shadow: 0 0 30px rgba(0, 0, 0, .1); text-align: center; border-radius: 20px; margin: 150px auto; } .btn{ position: relative; transform: translateY(-140px); transition: .3s; } .btn:hover{ cursor: pointer; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"wrap\"&gt; &lt;div class=\"photo_show\" id=\"app\"&gt; &lt;img @click=\"start_last()\" src=\"../images/last.png\" class=\"btn btn-last\"&gt; &lt;img :src=\"img_link\" class=\"img img1\"&gt; &lt;img @click=\"start_next()\" src=\"../images/next.png\" class=\"btn btn-next\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=\"../lib/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var link_index = 1; var app = new Vue({ el: '#app', data: { img_link: '../images/' + link_index + '.png' }, methods: { start_next: function (){ if(link_index &lt; 6){ link_index++ this.img_link = '../images/' + link_index + '.png'; }else{ this.img_link = '../images/1.png'; link_index = 1; } }, start_last: function (){ if(link_index &gt; 1){ link_index--; this.img_link = '../images/' + link_index + '.png'; }else{ this.img_link = '../images/6.png'; link_index = 6; } } }, mounted: function (){ setInterval(this.start_next(), 1000); } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/02/21/vue-practice1/"},{"title":"Vue 组件通信 | 练习","text":"这个练习目的是比较使用语法糖和不使用语法糖的效果，发现使用v-model绑定元素之后，通过组件去改变就容易很多，代码量可以少一点 未使用语法糖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt;total:{{ total }}&lt;/p&gt; &lt;!--使用v-on(这里使用了语法糖 @ )添加了两个事件监听器--&gt; &lt;!--两个事件会触发handleGetTotal事件--&gt;&gt; &lt;my-item @increase=\"handleGetTotal\" @reduce=\"handleGetTotal\"&gt;&lt;/my-item&gt; &lt;/div&gt; &lt;script src=\"lib/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; Vue.component('my-item', { template: ` &lt;div&gt; &lt;button @click=\"increase()\"&gt;+1&lt;/button&gt; &lt;button @click=\"reduce()\"&gt;-1&lt;/button&gt; &lt;/div&gt; `, data: function (){ return { counter: 0 } }, methods: { //点击+1按钮，触发此事件，counter加1，随后将更新的counter通过监听的increase监听器发送出去 increase: function (){ this.counter++; this.$emit('increase', this.counter); }, //点击-1按钮，触发此事件，counter减1，随后将更新的counter通过监听的increase监听器发送出去 reduce: function (){ this.counter--; this.$emit('reduce', this.counter); } } }); var app = new Vue({ el: '#app', data: { total: 0 }, methods: { //这个函数有一个参数，参数是组件按钮通过$emit()发出传过来的数据 //得到数据后，再把数据绑定到total，这样就是动态的 handleGetTotal: function (data){ this.total = data; } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用了语法糖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt;总数： &lt;span style=\"color: red; font-size: 30px;\"&gt;{{ total }}&lt;/span&gt;&lt;/p&gt; &lt;!-- 使用了v-model绑定了total --&gt; &lt;!--可以使用语法糖--&gt; &lt;my-item v-model=\"total\"&gt;&lt;/my-item&gt; &lt;/div&gt; &lt;script src=\"lib/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; Vue.component('my-item', { template: ` &lt;div&gt; &lt;button @click='increase()'&gt;+1&lt;/button&gt; &lt;button @click='reduce()'&gt;-1&lt;/button&gt; &lt;/div&gt; `, data: function (){ return { counter: 0 } }, methods: { increase: function(){ this.counter++; // 由于上面使用了v-model，这里就可以使用语法糖，直接用$emit绑定input，再传递数据 this.$emit('input', this.counter); }, reduce: function (){ this.counter--; // 由于上面使用了v-model，这里就可以使用语法糖，直接用$emit绑定input，再传递数据 this.$emit('input', this.counter); } } }) var app = new Vue({ el: '#app', data: { total: 0 } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/02/27/vue-practice3/"},{"title":"Vue实战 | 输入框组件","text":"笔记：在index-number.js中Vue组件内的watch里，每个成员的方法自带两个参数，前面是新的值，后面是旧的值，如下图所示 收获：组件内的数据是用props里定义的变量来传递，相当于一个中间人。 点击下面阅读更多查看代码 index.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input-number v-model='value' :max='10' :min='0'&gt;&lt;/input-number&gt; &lt;/div&gt; &lt;script src=\"../../../lib/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"index-number.js\"&gt;&lt;/script&gt; &lt;script src=\"index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.js 123456new Vue({ el: '#app', data: { value: 5 }}) index-number.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980function isValueNumber(value){ return (/(^-?[0-9]+\\.{1}\\d+$) | (^-?[1-9][0-9]*$) | (^-?0{1}$)/).test(value + '');};Vue.component('input-number', { template: ` &lt;div class='input-number'&gt; &lt;input type='text' :value='currentValue' @change='handleChange'/&gt; &lt;button @click='handleDown' :disable='currentValue &lt;= min'&gt;-&lt;/button&gt; &lt;button @click='handleUp' :disable='currentValue &gt;= min'&gt;+&lt;/button&gt; &lt;/div&gt; `, props: { max: { type: Number, default: Infinity }, min: { type: Number, default: -Infinity }, value: { type: Number, default: 0 } }, data: function (){ return { currentValue: this.value } }, watch: { currentValue: function (val, oldVal){ this.$emit('input', val); this.$emit('on-change', val); this.$emit('old', oldVal); }, value: function(val){ this.updateValue(val); } }, methods: { updateValue: function (val){ if (val &gt; this.max) val = this.max; if (val &lt; this.min) val = this.min; this.currentValue = val; }, handleDown: function (){ if (this.currentValue &lt;= this.min) return; this.currentValue -= 1; }, handleUp: function(){ if (this.currentValue &gt;= this.max) return; this.currentValue += 1; }, handleChange: function (event){ var val = event.target.value.trim(); var max = this.max; var min = this.min; if(isValueNumber(val)){ val = Number(val); this.currentValue = val; if(val &gt; max){ this.currentValue = max; }else if(val &lt; min){ this.currentValue = min; } }else{ event.target.value = this.currentValue; } } }, mounted: function (){ this.updateValue(this.value); this.$on('old', function (val){ console.log(val); }) }})","link":"/2020/03/04/vue-practice4/"},{"title":"Vue 实战|列表管理","text":"一个针对之前所学内容做的练习，用BootStrap做的样式，学习了js中几种新的遍历数组的方法（forEach, some, filter, findIndex） 在渲染列表的时候，没有直接使用data中carList的内容，而是对data中的carList用自定义的search方法进行了处理得到的返回值，便于查找 由于初始化时搜索的输入框没有内容，所以可以吧carList中的全部内容渲染到table里，当输入框输入了内容，table里渲染的内容就是在carList中匹配到的数据，这样搜索功能就实现了 --- 源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"lib/bootstrap.min.css\"&gt; &lt;script src=\"lib/vue.js\"&gt;&lt;/script&gt; &lt;style&gt; [v-cloak]{ display: none; } .l1{ margin-left: 20px; } button{ margin-left: 20px; } .panel-body{ margin-bottom: 20px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\" v-cloak&gt; &lt;div class=\"panel panel-primary\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3 class=\"panel-title\"&gt;CarList&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body form-inline\"&gt; &lt;label class=\"l1\"&gt; &lt;span style=\"margin-right: 10px;\"&gt;Id: &lt;/span&gt; &lt;input type=\"text\" class=\"form-control\" v-model='id'&gt; &lt;/label&gt; &lt;label for=\"\" class=\"l1\"&gt; &lt;span style=\"margin-right: 10px;\"&gt;Name:&lt;/span&gt; &lt;input type=\"text\" class=\"form-control\" v-model='name'&gt; &lt;/label&gt; &lt;button class=\"btn btn-primary\" @click='add'&gt;添加&lt;/button&gt; &lt;label for=\"\" class=\"l1\"&gt; &lt;span style=\"margin-right: 10px;\"&gt;Search:&lt;/span&gt; &lt;input type=\"text\" class=\"form-control\" v-model='keywords'&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class=\"table table-bordered table-hover\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;添加时间&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!--第一种，直接从data里的carList获取数据--&gt; &lt;!-- &lt;tr v-for='(item, index) in carList'&gt; &lt;td&gt;{{ index + 1 }}&lt;/td&gt; &lt;td&gt;{{ item.name }}&lt;/td&gt; &lt;td&gt;{{ item.time | formatDate }}&lt;/td&gt; &lt;td&gt; &lt;button class=\"btn btn-danger\" @click.present='remove(index)'&gt;删除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; --&gt; &lt;!--第二种，自定义一个search方法，同时把搜索的 关键字通过传参传递给了search方法--&gt; &lt;tr v-for='item in search(keywords)'&gt; &lt;td&gt;{{ item.id }}&lt;/td&gt; &lt;td&gt;{{ item.name }}&lt;/td&gt; &lt;td&gt;{{ item.time | formatDate }}&lt;/td&gt; &lt;td&gt; &lt;button class=\"btn btn-danger\" @click='remove(item.id)'&gt;删除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;script&gt; var DateFormat = function (value){ return value &lt; 10 ? '0' + value : value; }; var app = new Vue({ el: '#app', data: { id: '', name: '', keywords: '', carList: [ { id: 1, name: '宝马 M4', time: new Date() }, { id: 2, name: '奔驰 C63s', time: new Date() }, { id: 3, name: '奥迪 RS6 Avent', time: new Date() } ] }, filters: { formatDate: function (){ var date = new Date(); var year = date.getFullYear(); var month = DateFormat(date.getMonth() + 1); var day = DateFormat(date.getDay()); var hours = DateFormat(date.getHours()); var minutes = DateFormat(date.getMinutes()); var seconds = DateFormat(date.getSeconds()); //ES6语法，使用占位符可以简化语句 return `${ year }-${ month }-${ day } ${ hours }:${ minutes }:${ seconds }`; } }, methods: { remove: function(index){ this.carList.splice(index, 1); }, add: function (){ var car = { id: this.id, name: this.name, time: new Date() }; if(this.id == '' || this.name == ''){ alert('请输入内容！'); }else{ this.carList.push(car); this.id = ''; this.name = ''; } }, search: function (keywords){ //注意： forEach, some, filter, findIndex 这些都是属于数组的新方法， //都会对数组中的每一项进项遍历，执行相关操作 // 第一种遍历方法 // var newList = []; // this.carList.forEach(item =&gt; { // if(item.name.indexOf(keywords) != -1){ // newList.push(item); // } // }); // return newList; // 第二种遍历方法 return this.carList.filter(item =&gt; { if(item.name.includes(keywords)){ return item; } }) } } });&lt;/script&gt;","link":"/2020/03/10/vue-practice5/"},{"title":"Vue路由嵌套","text":"必须注意的两个点 子路由的router-link中的path必须是完整的path（带父级path），例如父级是/parent，子级是/son，那么子路由的router-link中的path必须为/parent/son； routes里的children中的子路由的path前面不能带 /，例如： 123456789101112routes: [ { path: '/parent', component: parent, children: [ { path: 'son',//这里就没有前面的 / component: son } ] }] 点击阅读更多查看代码 1234567891011121314151617&lt;div id='app'&gt; &lt;router-link to=\"/home\"&gt;首页&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;template id=\"home\"&gt; &lt;div&gt; &lt;h3&gt;Home&lt;/h3&gt; &lt;router-link to=\"/home/son\"&gt;Son&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id=\"son\"&gt; &lt;div&gt; &lt;h4&gt;I am Son&lt;/h4&gt; &lt;p&gt;Lorem, ipsum dolor sit amet consectetur adipisicing elit. Nesciunt in voluptatibus expedita repudiandae. Soluta distinctio quod quos dolorem blanditiis magni molestiae, minima dolores ipsum! Minima possimus sunt eius quis debitis!&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; 12345678910111213141516171819202122var home = { template: '#home' } var son = { template: '#son' } var router = new VueRouter({ routes: [ { path: '/home', component: home, children: [ {path: 'son', component: son} ] }, ], linkActiveClass: 'myActive' }) var app = new Vue({ el: '#app', router: router, })","link":"/2020/03/25/vue-router1/"},{"title":"Vue-基础 购物车小组件","text":"一个基于Vue基础指令的简单的购物车 Demo index.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Shop&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"style.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\" v-cloak&gt; &lt;template v-if=\"list.length\"&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;商品名称&lt;/th&gt; &lt;th&gt;商品单价&lt;/th&gt; &lt;th&gt;购买数量&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=\"(item, index) in list\"&gt; &lt;td&gt;{{ index + 1 }}&lt;/td&gt; &lt;td&gt;{{ item.name }}&lt;/td&gt; &lt;td&gt;{{ item.price }}&lt;/td&gt; &lt;td&gt; &lt;button class='fun' type=\"button\" @click=\"handleReduce(index)\":disabled=\"item.count === 1\"&gt;-&lt;/button&gt; {{ item.count }} &lt;button class='fun' type=\"button\" @click=\"handleAdd(index)\"&gt;+&lt;/button&gt; &lt;/td&gt; &lt;td&gt; &lt;button @click=\"handleRemove(index)\"&gt;移除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div&gt;总价：￥ {{ totalPrice }}&lt;/div&gt; &lt;/template&gt; &lt;div v-else&gt;购物车为空&lt;/div&gt; &lt;/div&gt; &lt;script src=\"../lib/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"index.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; index.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var app = new Vue({ el: '#app', data: { list: [ { id: 1, name: 'iPhone 7', price: 6188, count: 1 }, { id: 2, name: 'iPad Pro', price: 2888, count: 1 }, { id: 3, name: 'MacBook Pro', price: 21488, count: 1 } ], text: 'ss' }, computed: { totalPrice: function (){ var total = 0; for(var i = 0; i &lt; this.list.length; i++){ var item = this.list[i]; total += item.price * item.count; } return total.toString().replace(/\\B(?=(\\d{3})+$)/g, ','); } }, methods: { handleReduce: function (index){ if(this.list[index].count === 1) return; this.list[index].count--; }, handleAdd: function (index){ this.list[index].count++; }, handleRemove: function (index){ this.list.splice(index, 1); } }}); style.css 12345678910111213141516171819202122232425262728293031323334353637383940*{ margin: 0; padding: 0; font-family: 'XHei';}#app{ width: 500px; height: 500px; padding: 20px; border-radius: 10px; box-shadow: 0 0 30px rgba(0,0,0,.1); margin: 20px;}table{ width: 500px; height: 200px; border: #0000FF solid 1px; border-collapse: collapse; margin-bottom: 20px;}th{ border: 1px solid #0000FF; text-align: center;}th:hover{ background-color: #c4e4ff;}tbody{ vertical-align: middle;}td{ border:solid #3190E8 1px; text-align: center;}td:hover{ background-color: #F5F5F5;}button.fun{ width: 20px;}","link":"/2020/02/10/vue-shop/"},{"title":"Vue slot的使用","text":"个人理解 slot是一个插槽，和vue使用data的数据一样，也和input的placeholder一样，一个占位符，父组件内没有东西的时候，就会显示slot的默认内容，父组件有内容就会覆盖slot的默认内容 可以在组件模板内给每个slot一个name，当使用组件时，就可以通过slot的name来动态更新组件内容。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .panel{ border: 1px solid #000; border-radius: .2em; } .panel &gt; *{ padding: 15px; } .title{ border-bottom: 1px solid #000; } .content{ border-bottom: 1px solid #000; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;panel&gt; &lt;div slot=\"title\"&gt;This is title&lt;/div&gt; &lt;div slot=\"content\"&gt; Lorem ipsum, dolor sit amet consectetur adipisicing elit. Illum ex blanditiis, delectus ab, placeat deserunt fuga at suscipit numquam pariatur quia perferendis optio ea repudiandae voluptatum, nobis omnis eos tempora? &lt;/div&gt; &lt;div slot=\"footer\"&gt;This is footer&lt;/div&gt; &lt;/panel&gt; &lt;/div&gt; &lt;template id=\"panel\"&gt; &lt;div id=\"app\" class=\"panel\"&gt; &lt;div class=\"title\"&gt; &lt;slot name=\"title\"&gt;title&lt;/slot&gt; &lt;/div&gt; &lt;div class=\"content\"&gt; &lt;slot name=\"content\"&gt;Content&lt;/slot&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt; &lt;slot name=\"footer\"&gt;Footer&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script src=\"lib/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; Vue.component('panel', { template: '#panel', }) var app = new Vue({ el: '#app', }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/02/29/vue-slot/"},{"title":"Vue中监听数据变化的两种方式","text":"当vue中的数据有变化，例如用户输入新的数据之后，如何处理更新后的数据？这就提供了针对这种情况的两种方式。 使用keyup1234567891011&lt;div id=\"app\"&gt; &lt;!-- 分析： --&gt; &lt;!-- 1. 我们要监听到 文本框数据的改变，这样才能知道 什么时候去拼接 出一个 fullname --&gt; &lt;!-- 2. 如何监听到 文本框的数据改变呢？？？ --&gt; &lt;input type=\"text\" v-model=\"firstname\" @keyup=\"getFullname\"&gt; + &lt;input type=\"text\" v-model=\"lastname\" @keyup=\"getFullname\"&gt; = &lt;input type=\"text\" v-model=\"fullname\"&gt; &lt;/div&gt; 12345678910111213141516&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { firstname: '', lastname: '', fullname: '' }, methods: { getFullname() { this.fullname = this.firstname + '-' + this.lastname } } }); &lt;/script&gt; 使用watch, watch中监听添加的需要被监听的组件，用一个带有两个参数的函数处理更新后的数据1234567&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"firstname\"&gt; + &lt;input type=\"text\" v-model=\"lastname\"&gt; = &lt;input type=\"text\" v-model=\"fullname\"&gt; &lt;/div&gt; 12345678910111213141516171819202122232425&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { firstname: '', lastname: '', fullname: '' }, methods: {}, watch: { // 使用这个 属性，可以监视 data 中指定数据的变化，然后触发这个 watch 中对应的 function 处理函数 'firstname': function (newVal, oldVal) { // console.log('监视到了 firstname 的变化') // this.fullname = this.firstname + '-' + this.lastname // console.log(newVal + ' --- ' + oldVal) this.fullname = newVal + '-' + this.lastname }, 'lastname': function (newVal) { this.fullname = this.firstname + '-' + newVal } } }); &lt;/script&gt;","link":"/2020/03/25/vue-twoWayToUpdateDate/"},{"title":"开始学习webpack啦！ 使用webpack处理一个简易的项目","text":"这只是开始学习webpack的第一步，确是我人生的一大步。介绍：webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具；Webpack是基于整个项目进行构建的；借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。 准备工作 新建一个项目文件夹 在这个项目文件夹下新建名为dist、src的文件夹 在src文件夹下新建名为css、images、js的三个文件夹 在src文件夹下新建名为index.html和main.js的文件 上述步骤完成之后，在编辑器终端中进入这个项目文件夹，依次执行以下命令 npm init //初始化 npm install webpack --save-dev // 安装webpack --- 项目实例index.html123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"../src/main.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;Hello Vue 1&lt;/li&gt; &lt;li&gt;Hello Vue 2&lt;/li&gt; &lt;li&gt;Hello Vue 3&lt;/li&gt; &lt;li&gt;Hello Vue 4&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; main.js123456// 这个例子是安装了jquery之后import $ from 'jquery'$(function (){ $('li:odd').css('backgroundColor', 'lightred') $('li:even').css('backgroundColor', 'lightpink')}) 当index.html和main.js写好之后，直接打开index.html是看不到效果的，srcipt标签引用的main.js不能直接被浏览器解析，第一行import $ from 'jquery'就属于es6的高级语法，浏览器不能解析。这样就开始webpack的第一次使用，在终端运行webpack ./src/main.js -o ./dist/bundle.js --mode=none,等待执行完毕 - - - Asset就为webpack处理后的js文件，这样一来，修改script标签中的src为src='../dist/bundle.js'就可以看到页面成功渲染为main.js中的样式 问题来了：每次编译都要输入webpack ./src/main.js -o ./dist/bundle.js --mode=none很麻烦，怎么变简单一点？解决： 配置webpack配置文件，在项目根目录新建一个名为webpack.config.js的文件,设置简易配置:entry: 入口文件，要被webpack处理的文件output: 出口，webpack处理后的放置文件的目录和文件名（默认为bundle.js） 123456789const path = require('path') module.exports = { mode: 'none', entry: path.join(__dirname, './src/main.js'), output: { path: path.join(__dirname, './dist'), filename: 'bundle.js' } } 这样一来，直接在终端运行webpack即可使用webpack处理 有新的问题： 开发中修改代码是常事，每次修改了都要输入webpack命令然后打开网页刷新，很麻烦，怎么修改之后自动编译并且刷新页面解决：使用webpack-dev-server来自动化处理如果运行npm run dev出现can’t find moudle这种错误，删除掉项目中的node_modules目录重新在终端执行npm install即可 安装：npm install webpack-dev-server -D 设置项目的package.json，在scripts中添加一条：&quot;dev&quot;: &quot;webpack-dev-server&quot;并保存 项目终端运行npm run dev就可以运行,输出的log中的http://localhost:8080/即为项目的本地服务器地址 修改script标签中的src为src='/bundle.js'，再点击本地服务器地址，点击页面中的src即可看见index.html并且已被正确渲染 现在只要main.js被修改并且保存了就会触发更新，自动刷新页面 - - -","link":"/2020/03/27/webpack-create/"},{"title":"webpack项目的创建及初始化","text":"sdf 步骤： 创建项目根目录Demo 在Demo目录下创建dist、src目录 在src目录下创建css、images、js文件夹 在src目录下创建main.js、index.html文件 在Demo根目录下创建webpack.config.js文件 文件结构图123456789|-- Demo |-- webpack.config.js // webpack配置文件，配置各种loader和plugin等 |-- dist // 打包后的存放目录 |-- src // 资源文件夹吧 |-- index.html // 项目入口 |-- main.js // 导入各种包的文件 |-- css // 存放样式的目录 |-- images // 存放图片资源的目录 |-- js // 存放其他脚本文件 准备工作完了，开始创建 使用npm install webpack --save-dev以依赖方式安装webpack 使用npm install webpack-cli --save-dev安装webpack脚手架 使用npm install webpack-dev-server --save-dev安装webpack工具，这样可以自动打包项目并更新 测试编辑webpack.config.js配置文件如下： 12345678const path = require('path'); module.exports = { entry: './src/man.js', // 入口，需要被webpack编译打包的文件 output: { // 出口 path: path.resolve(__dirname, './dist'), // 打包出口路径 filename: 'bundle.js' // 打包后的文件名 }} 在package.json文件中的scripts下新建一条规则： 1234567\"dev\": \"webpack-dev-server --open --contentBase src --hot\"--open 是自动打开项目地址--contentBase 参数是src，默认打开项目地址中的src，也就是启动项目会自动打开index.html这个项目入口--hot 热更新，在代码中更改了页面中的某些样式的时候，页面不用刷新也能看到样式的改变 使用npm install jquery --save-dev安装jquery做一下测试 安装完成jQuery之后，在main.js写几条语句测试： 12345import $ from 'jquery';$(function(){ $('#app').css('color','red');}) 在index.html中添加一个id为app的div，并引入bundle.js 1234&lt;script src='/bundlr.js'&gt;&lt;/script&gt;&lt;div id='app'&gt;&lt;/div&gt; 现在所有基本工作已结束，使用npm run dev运行项目，运行成功没有报错的话会在默认浏览器中自动打开项目的src中的index.html并且已经成功看到id为app的div中的字体颜色为红色了。 完善项目配置在上述步骤中，其实还没发挥webpack的真正实力，现在通过对webpack.config.js进行配置，逐步来实现webpack更强大的功能。 借参考资料上面的说明：在webpack的世界里，每个文件都是一个模块，比如.css、.js、.html、.less等。对于不同的模块，webpack不能直接识别，所以就需要不同的加载器(loader)来处理，而加载器就是webpack最重要的功能。通过安装不同的加载器可以对各种后缀名的文件进行处理。接下来就是一些loader的使用","link":"/2020/04/27/webpack-dev-server_create/"},{"title":"webpack中的各种loader的安装及使用案例","text":"webpack在不使用loader的情况下很多语句都不能被解析，所以需要不同的第三方loader来解析不能被webpack解析的语句。 css loader安装： npm install style-loader css-loader 配置（在webpack.config.js的module中新建一条rules）： test: /.css$/, use: [‘style-loader’, ‘css-loader’] url loader安装（file-loader为url-loader的内部依赖，在规则里可以不用写url-loader）： npm install url-loader file-loader 配置（在webpack.config.js的module中新建一条rules,这里以图片举例）： test: /.(jpg|png|gif|bmp|jpeg)$/, use: [‘url-loader?limit=7000’] //针对图片test: /.(ttf|eot|svg|woff|woff2)$/, use: [‘url-loader’] //针对字体 给url-loader添加参数，不让所有的图片都被解析为Base64格式，上面的?limit=7000意思是如果图片大小等于或者大于7000字节则图片不会被转为Base64编码格式（limit单位为byte），如果小于，则会被转为Base64格式。 在webpack中使用 vue 开发 npm install vue -D 配置webpack.config.js（在resolve中的alias中添加一条规则）： 12345resolve: { alias: { \"vue\": \"vue/dist/vue.js\" }} 在main.js中添加一条语句 1import Vue from \"vue\" vue-loader在webpack中，推荐使用 .vue 这个组件模板文件定义组件，所以需要安装 vue-loader npm install vue-loader vue-template-compiler -D 上述vue-loader安装完成后，就可以使用webpack来创建一个组件并用render函数来渲染到页面上 在js目录中新建一个login.vue文件，内容如下（vue模板，包含三部分）： 123456789&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是登录组件&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 在main.js中导入这个组件，导入vue，并且new一个vue实例，并注册从login.vue导入的组件 1234567891011121314import Vue from 'vue'import login from './src/js/login.vue'var app = new Vue({ el:'#app', components: { 'login': login }, //原始版： render: function(createElement){ return createElement(login) } //简写版： render: c =&gt; c(login)}) 最后在index.html中创建一个id为app的div元素，作为app的实例要控制的区域 123&lt;div id='app'&gt; &lt;login&gt;&lt;/login&gt;&lt;/div&gt;","link":"/2020/03/29/webpack-loaders/"}],"tags":[{"name":"跨域","slug":"跨域","link":"/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"Windows技巧","slug":"Windows技巧","link":"/tags/Windows%E6%8A%80%E5%B7%A7/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"MarkDown","slug":"MarkDown","link":"/tags/MarkDown/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"项目","slug":"项目","link":"/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"Python,爬虫","slug":"Python-爬虫","link":"/tags/Python-%E7%88%AC%E8%99%AB/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"笔记, Vue.js, Webpack","slug":"笔记-Vue-js-Webpack","link":"/tags/%E7%AC%94%E8%AE%B0-Vue-js-Webpack/"},{"name":"激活","slug":"激活","link":"/tags/%E6%BF%80%E6%B4%BB/"},{"name":"Vue笔记","slug":"Vue笔记","link":"/tags/Vue%E7%AC%94%E8%AE%B0/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"}],"categories":[{"name":"webpack","slug":"webpack","link":"/categories/webpack/"},{"name":"web学习","slug":"web学习","link":"/categories/web%E5%AD%A6%E4%B9%A0/"},{"name":"Github","slug":"Github","link":"/categories/Github/"},{"name":"电脑相关","slug":"电脑相关","link":"/categories/%E7%94%B5%E8%84%91%E7%9B%B8%E5%85%B3/"},{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"},{"name":"个人Blog","slug":"个人Blog","link":"/categories/%E4%B8%AA%E4%BA%BABlog/"},{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"Vue.js","slug":"Vue-js","link":"/categories/Vue-js/"},{"name":"Python","slug":"Python","link":"/categories/Python/"}]}